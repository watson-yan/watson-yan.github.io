{"meta":{"title":"watson yan","subtitle":null,"description":null,"author":"watson yan","url":"http://huayan.site"},"pages":[{"title":"categories","date":"2017-05-15T07:59:13.000Z","updated":"2017-05-15T07:59:13.000Z","comments":true,"path":"categories/index.html","permalink":"http://huayan.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-15T08:08:12.000Z","updated":"2017-05-15T08:08:12.000Z","comments":false,"path":"tags/index.html","permalink":"http://huayan.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一小时掌握600个程序员词汇","slug":"一小时掌握600个程序员词汇","date":"2017-10-25T04:51:22.000Z","updated":"2017-10-25T14:02:14.000Z","comments":true,"path":"2017/10/25/一小时掌握600个程序员词汇/","link":"","permalink":"http://huayan.site/2017/10/25/一小时掌握600个程序员词汇/","excerpt":"","text":"function : 函式、函数 函数application : 应用程式 应用、应用程序architecture : 架构、系统架构 体系结构argument : 引数（传给函式的值）。参见 parameter 参数、实质参数、实参、自变量array : 阵列 数组arrow operator arrow: （箭头）运算子 箭头操作符assembly : 装配件assembly language : 组合语言 汇编语言assert(ion) : 断言assign : 指派、指定、设值、赋值 赋值assignment : 指派、指定 赋值、分配assignment operator : 指派（赋值）运算子 = 赋值操作符associated : 相应的、相关的 相关的、关联、相应的associative container : 关联式容器（对应 sequential container） 关联式容器atomic : 不可分割的 原子的attribute : 属性 属性、特性audio : 音讯 音频A.I. : 人工智慧 人工智能background : 背景 背景（用於图形着色） 后台（用於行程）backward compatible : 回溯相容 向下兼容bandwidth : 频宽 带宽base class : 基础类别 基类base type : 基础型别 (等同於 base class)batch : 批次（意思是整批作业） 批处理benefit : 利益 收益best viable function : 最佳可行函式 最佳可行函式 （从 viable functions 中挑出的最佳吻合者）binary search : 二分搜寻法 二分查找binary tree : 二元树 二叉树binary function : 二元函式 双参函数binary operator : 二元运算子 二元操作符binding : 系结 绑定bit : 位元 位bit field : 位元栏 位域bitmap : 位元图 位图bitwise : 以 bit 为单元逐一┅bitwise copy : 以 bit 为单元进行复制；位元逐一复制 位拷贝block : 区块,区段 块、区块、语句块boolean : 布林值（真假值，true 或 false） 布尔值border : 边框、框线 边框brace(curly brace) : 大括弧、大括号 花括弧、花括号bracket(square brakcet) : 中括弧、中括号 方括弧、方括号breakpoint : 中断点 断点build : 建造、构筑、建置（MS 用语）build－in : 内建 内置bus : 汇流排 总线business : 商务,业务 业务buttons : 按钮 按钮byte : 位元组（由 8 bits 组成） 字节cache : 快取 高速缓存call : 呼叫、叫用 调用callback : 回呼 回调call operator call: （函式呼叫）运算子调用操作符 ###### （同 function call operator）candidate function : 候选函式 候选函数 ###### （在函式多载决议程序中出现的候选函式）chain : 串链（例 chain of function calls） 链character : 字元 字符check box : 核取方块 (i.e. check button) 复选框checked exception : 可控式异常(Java)check button : 方钮 (i.e. check box) 复选按钮child class : 子类别（或称为derived class, subtype） 子类class : 类别 类class body : 类别本体 类体class declaration : 类别宣告、类别宣告式 类声明class definition : 类别定义、类别定义式 类定义class derivation list : 类别衍化列 类继承列表class head : 类别表头 类头class hierarchy : 类别继承体系, 类别阶层 类层次体系class library : 类别程式库、类别库 类库class template : 类别模板、类别范本 类模板class template partial specializations ###### : 类别模板偏特化 类模板部分特化class template specializations ###### : 类别模板特化 类模板特化cleanup : 清理、善后 清理、清除client : 客端、客户端、客户 客户client－server : 主从架构 客户/服务器clipboard : 剪贴簿 剪贴板clone : 复制 克隆collection : 群集 集合combo box : 复合方块、复合框 组合框command line : 命令列 命令行 (系统文字模式下的整行执行命令)communication : 通讯 通讯compatible : 相容 兼容compile time : 编译期 编译期、编译时compiler : 编译器 编译器component : 组件 组件composition : 复合、合成、组合 组合computer : 电脑、计算机 计算机、电脑concept : 概念 概念concrete : 具象的 实在的concurrent : 并行 并发configuration : 组态 配置connection : 连接，连线（网络,资料库） 连接constraint : 约束（条件）construct : 构件 构件container : 容器 容器 ###### （存放资料的某种结构如 list, vector…）containment : 内含 包容context : 背景关系、周遭环境、上下脉络 环境、上下文control : 控制元件、控件 控件console : 主控台 控制台const : 常数（constant 的缩写，C++ 关键字）constant : 常数（相对於 variable） 常量constructor : 建构式 构造函数 ###### （与class 同名的一种 member functions）copy: 动词：复制、拷贝 拷贝copy: 名词：复件, 副本cover : 涵盖 覆盖create : 创建、建立、产生、生成 创建creation : 产生、生成 创建cursor : 游标 光标custom : 订制、自定 定制data : 资料 数据database : 资料库 数据库database schema : 数据库结构纲目data member : 资料成员、成员变数 数据成员、成员变量data structure : 资料结构 数据结构datagram : 资料元 数据报文dead lock : 死结 死锁debug : 除错 调试debugger : 除错器 调试器declaration : 宣告、宣告式 声明deduction : 推导（例：template argument deduction） 推导、推断default : 预设 缺省、默认defer : 延缓 推迟define : 定义 预定义definition : 定义、定义区、定义式 定义delegate : 委派、委托、委任 委托delegation : （同上）demarshal : 反编列 散集dereference : 提领（取出指标所指物体的内容） 解参考dereference operator dereference: （提领）运算子 解参考操作符derived class : 衍生类别 派生类design by contract : 契约式设计design pattern : 设计范式、设计样式 设计模式 ※ 最近我比较喜欢「设计范式」一词destroy : 摧毁、销毁destructor : 解构式 析构函数device : 装置、设备 设备dialog : 对话窗、对话盒 对话框directive : 指令（例：using directive） (编译)指示符directory : 目录 目录disk : 碟 盘dispatch : 分派 分派distributed computing : 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算)document : 文件 文档dot operator dot: （句点）运算子 . (圆)点操作符driver : 驱动程式 驱动（程序）dynamic binding : 动态系结 动态绑定efficiency : 效率 效率efficient : 高效 高效end user : 终端用户entity : 物体 实体、物体encapsulation : 封装 封装enclosing class : 外围类别（与巢状类别 nested class 有关）外围类enum (enumeration) : 列举（一种 C++ 资料型别） 枚举enumerators : 列举元（enum 型别中的成员） 枚举成员、枚举器equal : 相等 相等equality : 相等性 相等性equality operator equality: （等号）运算子 == 等号操作符equivalence : 等价性、等同性、对等性 等价性equivalent : 等价、等同、对等 等价escape code : 转义码 转义码evaluate : 评估、求值、核定 评估event : 事件 事件event driven : 事件驱动的 事件驱动的exception : 异常情况 异常exception declaration : 异常宣告（ref. C++ Primer 3/e, 11.3） 异常声明exception handling : 异常处理、异常处理机制 异常处理、异常处理机制exception specification : 异常规格（ref. C++ Primer 3/e, 11.4） 异常规范exit : 退离（指离开函式时的那一个执行点） 退出explicit : 明白的、明显的、显式 显式export : 汇出 引出、导出expression : 运算式、算式 表达式facility : 设施、设备 设施、设备feature : 特性field : 栏位,资料栏（Java） 字段, 值域（Java）file : 档案 文件firmware : 韧体 固件flag : 旗标 标记flash memory : 快闪记忆体 闪存flexibility : 弹性 灵活性flush : 清理、扫清 刷新font : 字型 字体form : 表单（programming 用语） 窗体formal parameter : 形式参数 形式参数forward declaration : 前置宣告 前置声明forwarding : 转呼叫,转发 转发forwarding function : 转呼叫函式,转发函式 转发函数fractal : 碎形 分形framework : 框架 框架full specialization : 全特化（ref. partial specialization）function : 函式、函数 函数function call operator : 同 call operatorfunction object : 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象function overloaded resolution : 函式多载决议程序 函数重载解决（方案）functionality : 功能、机能 功能function template : 函式模板、函式范本 函数模板functor : 仿函式 仿函式、函子game : 游戏 游戏generate : 生成generic : 泛型、一般化的 一般化的、通用的、泛化generic algorithm : 泛型演算法 通用算法getter: (相对於 setter) 取值函式global : 全域的（对应於 local） 全局的global object : 全域物件 全局对象global scope resolution operator : 全域生存空间（范围决议）运算子 :: 全局范围解析操作符group : 群组group box : 群组方块 分组框guard clause : 卫述句 (Refactoring, p250) 卫语句GUI : 图形介面 图形界面hand shaking : 握手协商handle : 识别码、识别号、号码牌、权柄 句柄handler : 处理常式 处理函数hard－coded : 编死的 硬编码的hard－copy : 硬拷图 屏幕截图hard disk : 硬碟 硬盘hardware : 硬体 硬件hash table : 杂凑表 哈希表、散列表header file : 表头档、标头档 头文件heap : 堆积 堆hierarchy : 阶层体系 层次结构（体系）hook : 挂钩 钩子hyperlink : 超链结 超链接icon : 图示、图标 图标IDE : 整合开发环境 集成开发环境identifier : 识别字、识别符号 标识符if and only if : 若且唯若 当且仅当Illinois : 伊利诺 伊利诺斯image : 影像 图象immediate base : 直接的（紧临的）上层 base class。 直接上层基类immediate derived : 直接的（紧临的）下层 derived class。 直接下层派生类immutability : 不变性immutable : 不可变（的）implement : 实作、实现 实现implementation : 实作品、实作体、实作码、实件 实现implicit : 隐喻的、暗自的、隐式 隐式import : 汇入 导入increment operator : 累加运算子 ++ 增加操作符infinite loop : 无穷回圈 无限循环infinite recursive : 无穷递回 无限递归information : 资讯 信息infrastructure : 公共基础建设inheritance : 继承、继承机制 继承、继承机制inline : 行内 内联inline expansion : 行内展开 内联展开initialization : 初始化（动作） 初始化initialization list : 初值列 初始值列表initialize : 初始化 初始化inner class : 内隐类别 内嵌类instance : 实体 实例 ###### （根据某种表述而实际产生的「东西」）instantiated : 具现化、实体化（常应用於 template） 实例化instantiation : 具现体、具现化实体（常应用於 template） 实例integer (integral) : 整数（的） 整型（的）integrate : 整合 集成interacts : 交谈、互动 交互interface : 介面 接口for GUI : 介面 界面interpreter : 直译器 解释器invariants : 恒常性,约束条件 约束条件invoke : 唤起 调用iterate : 迭代（回圈一个轮回一个轮回地进行） 迭代exception : 异常情况 异常exception declaration : 异常宣告（ref. C++ Primer 3/e, 11.3） 异常声明exception handling : 异常处理、异常处理机制 异常处理、异常处理机制exception specification : 异常规格（ref. C++ Primer 3/e, 11.4） 异常规范exit : 退离（指离开函式时的那一个执行点） 退出explicit : 明白的、明显的、显式 显式export : 汇出 引出、导出expression : 运算式、算式 表达式facility : 设施、设备 设施、设备feature : 特性field : 栏位,资料栏（Java） 字段, 值域（Java）file : 档案 文件firmware : 韧体 固件flag : 旗标 标记flash memory : 快闪记忆体 闪存flexibility : 弹性 灵活性flush : 清理、扫清 刷新font : 字型 字体form : 表单（programming 用语） 窗体formal parameter : 形式参数 形式参数forward declaration : 前置宣告 前置声明forwarding : 转呼叫,转发 转发forwarding function : 转呼叫函式,转发函式 转发函数fractal : 碎形 分形framework : 框架 框架full specialization : 全特化（ref. partial specialization）application framework : 应用程式框架、应用框架 应用程序框架function call operator : 同 call operatorfunction object : 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象function overloaded resolution : 函式多载决议程序 函数重载解决（方案）functionality : 功能、机能 功能function template : 函式模板、函式范本 函数模板functor : 仿函式 仿函式、函子game : 游戏 游戏generate : 生成generic : 泛型、一般化的 一般化的、通用的、泛化generic algorithm : 泛型演算法 通用算法getter (: 相对於 setter) 取值函式global : 全域的（对应於 local） 全局的global object : 全域物件 全局对象global scope resolution operator : 全域生存空间（范围决议）运算子 :: 全局范围解析操作符group : 群组group box : 群组方块 分组框guard clause : 卫述句 (Refactoring, p250) 卫语句GUI : 图形介面 图形界面hand shaking : 握手协商handle : 识别码、识别号、号码牌、权柄 句柄handler : 处理常式 处理函数hard－coded : 编死的 硬编码的hard－copy : 硬拷图 屏幕截图hard disk : 硬碟 硬盘hardware : 硬体 硬件hash table : 杂凑表 哈希表、散列表header file : 表头档、标头档 头文件heap : 堆积 堆hierarchy : 阶层体系 层次结构（体系）hook : 挂钩 钩子hyperlink : 超链结 超链接icon : 图示、图标 图标IDE : 整合开发环境 集成开发环境identifier : 识别字、识别符号 标识符if and only if : 若且唯若 当且仅当Illinois : 伊利诺 伊利诺斯image : 影像 图象immediate base : 直接的（紧临的）上层 base class。 直接上层基类immediate derived : 直接的（紧临的）下层 derived class。 直接下层派生类immutability : 不变性immutable : 不可变（的）implement : 实作、实现 实现implementation : 实作品、实作体、实作码、实件 实现implicit : 隐喻的、暗自的、隐式 隐式import : 汇入 导入increment operator : 累加运算子 ++ 增加操作符infinite loop : 无穷回圈 无限循环infinite recursive : 无穷递回 无限递归information : 资讯 信息infrastructure : 公共基础建设inheritance : 继承、继承机制 继承、继承机制inline : 行内 内联inline expansion : 行内展开 内联展开initialization : 初始化（动作） 初始化initialization list : 初值列 初始值列表initialize : 初始化 初始化inner class : 内隐类别 内嵌类instance : 实体 实例 ###### （根据某种表述而实际产生的「东西」）instantiated : 具现化、实体化（常应用於 template） 实例化instantiation : 具现体、具现化实体（常应用於 template） 实例integer (integral) : 整数（的） 整型（的）integrate : 整合 集成interacts : 交谈、互动 交互interface : 介面 接口for GUI : 介面 界面interpreter : 直译器 解释器invariants : 恒常性,约束条件 约束条件invoke : 唤起 调用iterate : 迭代（回圈一个轮回一个轮回地进行） 迭代iterative : 反覆的，迭代的iterator : 迭代器（一种泛型指标） 迭代器iteration : 迭代（回圈每次轮回称为一个 iteration） 迭代item : 项目、条款 项、条款、项目laser : 雷射 激光level : 阶 层 (级) 例 high level 高阶 高层library : 程式库、函式库 库、函数库lifetime : 生命期、寿命 生命期、寿命link : 联结、连结 连接,链接linker : 联结器、连结器 连接器literal constant : 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数list : 串列（linked－list） 列表、表、链表list box : 列表方块、列表框 列表框load : 载入 装载loader : 载入器 装载器、载入器local : 区域的（对应於 global） 局部的local object : 区域物件 局部对象lock : 机锁loop : 回圈 循环lvalue : 左值 左值macro : 巨集 宏magic number : 魔术数字 魔法数maintain : 维护 维护manipulator : 操纵器（iostream 预先定义的一种东西） 操纵器marshal : 编列 列集 参考 demarshalmechanism : 机制 机制member : 成员 成员member access operator : 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符member function : 成员函式 成员函数member initialization list : 成员初值列 成员初始值列表memberwise : 以 member 为单元┅、members 逐一┅ 以成员为单位memberwise copy : 以 members 为单元逐一复制memory : 记忆体 内存menu : 表单、选单 菜单message : 讯息 消息message based : 以讯息为基础的 基於消息的message loop : 讯息回圈 消息环method (java) : 方法、行为、函式 方法meta－ : 超－ 元－ 例 meta－programming 超编程 元编程micro : 微 微middleware : 中介层 中间件modeling : 模塑modeling language : 塑模语言，建模语言modem : 数据机 调制解调器module : 模组 模块modifier : 饰词 修饰符most derived class : 最末层衍生类别 最底层的派生类mouse : 滑鼠 鼠标mutable : 可变的 可变的multi－tasking : 多工 多任务namespace : 命名空间 名字空间、命名空间native : 原生的 本地的、固有的nested class : 巢状类别 嵌套类network : 网路 网络network card : 网路卡 网卡object : 物件 对象object based : 以物件为基础的 基於对象的object file : 目的档 目标文件object model : 物件模型 对象模型object oriented : 物件导向的 面向对象的online : 线上 在线opaque : 不透明的operand : 运算元 操作数operating system (OS) : 作业系统 操作系统operation : 操作、操作行为 操作operator : 运算子 操作符、运算符option : 选项，可选方案 选项ordinary : 常规的 常规的overflow : 上限溢位（相对於 underflow） 溢出（underflow:下溢）overhead : 额外负担、额外开销 额外开销overload : 多载化、多载化、重载 重载overloaded function : 多载化函式 重载的函数overloaded operator : 多载化运算子 被重载的操作符overloaded set : 多载集合 重载集合override : 改写、覆写 重载、改写、重新定义 ###### （在 derived class 中重新定义虚拟函式package : 套件 包pair : 对组palette : 调色盘、组件盘、工具箱pane : 窗格 窗格 ###### （有时为嵌板之意，例 Java Content Pane）parallel : 平行 并行parameter : 参数（函式参数列上的变数） 参数、形式参数、形参parameter list : 参数列 参数列表parent class : 父类别（或称 base class） 父类parentheses : 小括弧、小括号 圆括弧、圆括号parse : 解析 解析part : 零件 部件partial specialization : 偏特化（ref. C++ Primer 3/e, 16.10） 局部特化 ###### （ref. full specialization）pass by address : 传址（函式引数的传递方式）（非正式用语）传地址pass by reference : 传址（函式引数的一种传递方式） 传地址, 按引用传递pass by value : 传值（函式引数的一种传递方式） 按值传递pattern : 范式、样式 模式performance : 效率、性能兼而有之 性能persistence : 永续性 持久性pixel : 图素、像素 像素placement delete ref. C++ Primer 3/e, 15.8.: 2placement new ref. C++ Primer 3/e, 15.8.: 2platform : 平台 平台pointer : 指标 指针 址位器（和址参器 reference 形成对映，满好）poll : 轮询 轮询polymorphism : 多型 多态pop up : 冒起式、弹出式 弹出式port : 埠 端口postfix : 后置式、后序式 后置式precedence : 优先序（通常用於运算子的优先执行次序）prefix : 前置式、前序式 前置式preprocessor : 前处理器 预处理器prime : 质数 素数primitive type : 基本型别 (不同於 base class,基础类别)print : 列印 打印printer : 印表机 打印机priority : 优先权 (通常用於执行绪获得 CPU 时间的优先次序）procedure : 程序 过程procedural : 程序性的、程序式的 过程式的、过程化的process : 行程 进程profile : 评测 评测profiler : 效能（效率）评测器 效能（性能）评测器programmer : 程式员 程序员programming : 编程、程式设计、程式化 编程progress bar : 进度指示器 进度指示器project : 专案 项目、工程property : 属性protocol : 协定 协议pseudo code : 假码、虚拟码、伪码 伪码qualified : 经过资格修饰（例如加上 scope 运算子） 限定qualifier : 资格修饰词、饰词 限定修饰词quality : 品质 质量queue : 伫列 队列radian : 径度 弧度radio button : 圆钮 单选按钮raise : 引发（常用来表示发出一个 exception） 引起、引发random number : 随机数、乱数 随机数range : 范围、区间（用於 STL 时） 范围、区间rank : 等级、分等（ref. C++Primer 3/e 9,15章） 等级raw : 生鲜的、未经处理的 未经处理的record : 记录 记录recordset : 记录集 记录集recursive : 递回 递归re－direction : 重导向 重定向refactoring : 重构、重整 重构refer : 取用 参考refer to : 指向、指涉、指代reference : （C++中类似指标的东西，相当於 “化身”） 引用、参考 址参器, see pointerregister : 暂存器 寄存器reflection : 反射 反射、映像relational database : 关联式资料库 关系数据库represent : 表述，表现 表述，表现resolve : 决议（为算式中的符号名称寻找 解析 对应之宣告式的过程）resolution : 决议程序、决议过程 解析过程resolution : 解析度 分辨率restriction : 局限return : 传回、回返 返回return type : 回返型别 返回类型return value : 回返值 返回值robust : 强固、稳健 健壮robustness : 强固性、稳健性 健壮性routine : 常式 例程runtime : 执行期 运行期、运行时common language runtime : (CLR)译为「通用语言执行层」rvalue : 右值 右值save : 储存 存储schedule : 排程 调度scheduler : 排程器 调度程序scheme : 结构纲目、组织纲目scroll bar : 卷轴 滚动条scope : 生存空间、生存范围、范畴、作用域 生存空间scope operator : 生存空间（范围决议）运算子 :: 生存空间操作符scope resolution operator : 生存空间决议运算子 生存空间解析操作符 ###### （与scope operator同）screen : 萤幕 屏幕search : 搜寻 查找semantics : 语意 语义sequential container : 序列式容器 顺序式容器 ###### （对应於 associative container）server : 伺服器、伺服端 服务器、服务端serial : 串行serialization : 次第读写,序列化 序列化 (serialize)setter (: 相对於 getter) 设值函式signal : 信号signature : 标记式、签名式、署名式 签名slider : 滚轴 滑块slot : 条孔、槽 槽smart pointer : 灵巧指标、精灵指标 智能指针snapshot : 萤幕快照（图） 屏幕截图specialization : 特殊化、特殊化定义、特殊化宣告 特化specification : 规格 规格、规范splitter : 分裂视窗 切分窗口software : 软体 软件solution : 解法,解决方案 方案source : 原始码 源码、源代码stack : 堆叠 栈stack unwinding : 堆叠辗转开解（此词用於 exception 主题） 栈辗转开解 standard library : 标准程式库standard template library : 标准模板程式库statement : 述句 语句、声明status bar : 状态列、状态栏 状态条STL : 见 standard template librarystream : 资料流、串流 流string : 字串 字符串subroutin: esubscript operator : 下标运算子 [ ] 下标操作符subtype : 子型别 子类型support : 支援 支持suspend : 虚悬 挂起symbol : 符号 记号syntax : 语法 语法tag : 标签 标记 索引标签,页签target : 标的（例 target pointer：标的指标） 目标task switch : 工作切换 任务切换template : 模板、范本 模板template argument deduction : 模板引数推导 模板参数推导template explicit specialization : 模板显式特化（版本） 模板显式特化template parameter : 模板参数 模板参数temporary object : 暂时物件 临时对象text : 文字 文本","categories":[],"tags":[{"name":"单词","slug":"单词","permalink":"http://huayan.site/tags/单词/"}]},{"title":"JavaScript实现继承","slug":"Javascript实现继承","date":"2017-10-18T04:51:22.000Z","updated":"2017-10-18T09:39:57.000Z","comments":true,"path":"2017/10/18/Javascript实现继承/","link":"","permalink":"http://huayan.site/2017/10/18/Javascript实现继承/","excerpt":"","text":"转载自 segmentfultrigkit4 js继承的概念js里常用的如下两种继承方式： 原型链继承（对象间的继承） 类式继承（构造函数间的继承） 由于js不像java那样是真正面向对象的语言，js是基于对象的，它没有类的概念。所以，要想实现继承，可以用js的原型prototype机制或者用apply和call方法去实现 在面向对象的语言中，我们使用类来创建一个自定义对象。然而js中所有事物都是对象，那么用什么办法来创建自定义对象呢？这就需要用到js的原型： 我们可以简单的把prototype看做是一个模版，新创建的自定义对象都是这个模版（prototype）的一个拷贝 （实际上不是拷贝而是链接，只不过这种链接是不可见，新实例化的对象内部有一个看不见的Proto指针，指向原型对象）。 js可以通过构造函数和原型的方式模拟实现类的功能。 另外，js类式继承的实现也是依靠原型链来实现的。 原型式继承与类式继承类式继承是在子类型构造函数的内部调用超类型的构造函数。严格的类式继承并不是很常见，一般都是组合着用： 1234567function Super()&#123; this.colors=[\"red\",\"blue\"];&#125; function Sub()&#123; Super.call(this);&#125; 原型式继承是借助已有的对象创建新的对象，将子类的原型指向父类，就相当于加入了父类这条原型链 原型链继承为了让子类继承父类的属性（也包括方法），首先需要定义一个构造函数。然后，将父类的新实例赋值给构造函数的原型。代码如下： 1234567891011121314151617181920function Parent()&#123; this.name = 'mike';&#125;function Child()&#123; this.age = 12;&#125;Child.prototype = new Parent();//Child继承Parent，通过原型，形成链条var test = new Child();alert(test.age);alert(test.name);//得到被继承的属性//继续原型链继承function Brother()&#123; //brother构造 this.weight = 60;&#125;Brother.prototype = new Child();//继续原型链继承var brother = new Brother();alert(brother.name);//继承了Parent和Child,弹出mikealert(brother.age);//弹出12 以上原型链继承还缺少一环，那就是Object，所有的构造函数都继承自Object。而继承Object是自动完成的，并不需要我们自己手动继承，那么他们的从属关系是怎样的呢？ 确定原型和实例的关系可以通过两种方式来确定原型和实例之间的关系。操作符instanceof和isPrototypeof()方法： 1234alert(brother instanceof Object)//truealert(test instanceof Brother);//false,test 是brother的超类alert(brother instanceof Child);//truealert(brother instanceof Parent);//true 只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型，因此，isPrototypeof()方法也会返回true 在js中，被继承的函数称为超类型（父类，基类也行），继承的函数称为子类型（子类，派生类）。使用原型继承主要由两个问题：一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 伪类解决引用共享和超类型无法传参的问题，我们可以采用“借用构造函数”技术 借用构造函数（类式继承）12345678910111213function Parent(age)&#123; this.name = ['mike','jack','smith']; this.age = age;&#125;function Child(age)&#123; Parent.call(this,age);&#125;var test = new Child(21);alert(test.age);//21alert(test.name);//mike,jack,smithtest.name.push('bill');alert(test.name);//mike,jack,smith,bill 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起，所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合继承12345678910111213function Parent(age)&#123; this.name = ['mike','jack','smith']; this.age = age;&#125;Parent.prototype.run = function () &#123; return this.name + ' are both' + this.age;&#125;;function Child(age)&#123; Parent.call(this,age);//对象冒充，给超类型传参&#125;Child.prototype = new Parent();//原型链继承var test = new Child(21);//写new Parent(21)也行alert(test.run());//mike,jack,smith are both21 组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 call()的用法：调用一个对象的一个方法，以另一个对象替换当前对象。 1call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 原型式继承这种继承借助原型并基于已有的对象创建新对象，同时还不用创建自定义类型的方式称为原型式继承12345678910111213141516171819202122function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var box = &#123; name : 'trigkit4', arr : ['brother','sister','baba']&#125;;var b1 = obj(box);alert(b1.name);//trigkit4b1.name = 'mike';alert(b1.name);//mikealert(b1.arr);//brother,sister,babab1.arr.push('parents');alert(b1.arr);//brother,sister,baba,parentsvar b2 = obj(box);alert(b2.name);//trigkit4alert(b2.arr);//brother,sister,baba,parents 原型式继承首先在obj()函数内部创建一个临时性的构造函数 ，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。 寄生式继承这种继承方式是把原型式+工厂模式结合起来，目的是为了封装创建的过程。 function create(o){ var f= obj(o); f.run = function () { return this.arr;//同样，会共享引用 }; return f; } 组合式继承的小问题组合式继承是js最常用的继承模式，但组合继承的超类型在使用过程中会被调用两次；一次是创建子类型的时候，另一次是在子类型构造函数的内部 123456789101112131415function Parent(name)&#123; this.name = name; this.arr = ['哥哥','妹妹','父母'];&#125;Parent.prototype.run = function () &#123; return this.name;&#125;;function Child(name,age)&#123; Parent.call(this,age);//第二次调用 this.age = age;&#125;Child.prototype = new Parent();//第一次调用 以上代码是之前的组合继承，那么寄生组合继承，解决了两次调用的问题。 寄生组合式继承123456789101112131415161718192021222324252627282930313233function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;function create(parent,test)&#123; var f = obj(parent.prototype);//创建对象 f.constructor = test;//增强对象&#125;function Parent(name)&#123; this.name = name; this.arr = ['brother','sister','parents'];&#125;Parent.prototype.run = function () &#123; return this.name;&#125;;function Child(name,age)&#123; Parent.call(this,name); this.age =age;&#125;inheritPrototype(Parent,Child);//通过这里实现继承var test = new Child('trigkit4',21);test.arr.push('nephew');alert(test.arr);//alert(test.run());//只共享了方法var test2 = new Child('jack',22);alert(test2.arr);//引用问题解决 call和apply全局函数apply和call可以用来改变函数中this的指向，如下： 12345678910111213141516// 定义一个全局函数function foo() &#123; console.log(this.fruit);&#125;// 定义一个全局变量var fruit = \"apple\";// 自定义一个对象var pack = &#123; fruit: \"orange\"&#125;;// 等价于window.foo();foo.apply(window); // \"apple\",此时this等于window// 此时foo中的this === packfoo.apply(pack); // \"orange\"","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://huayan.site/tags/Javascript/"},{"name":"继承","slug":"继承","permalink":"http://huayan.site/tags/继承/"}]},{"title":"JavaScript闭包","slug":"JavaScript闭包","date":"2017-10-12T04:51:22.000Z","updated":"2017-10-11T08:31:14.000Z","comments":true,"path":"2017/10/12/JavaScript闭包/","link":"","permalink":"http://huayan.site/2017/10/12/JavaScript闭包/","excerpt":"","text":"什么是闭包？JavaScript的闭包是一个特色。官方解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。这句话相信有许多人看不懂。我来表述一下我对JavaScript闭包的理解：闭包的例子：1234567891011var count=10;//全局作用域 标记为flag1function add()&#123; var count=0;//函数全局作用域 标记为flag2 return function()&#123; count+=1;//函数的内部作用域 alert(count); &#125;&#125;var s=add()s();//输出1s();//输出2 add()的返回值是一个函数，首先第一次调用s()的时候，是执行add()的返回的函数，也就是下面这个函数：1234function()&#123; count+=1;//函数的内部作用域 alert(count);&#125; 也就是将count+1，在输出，那count是从哪儿来的的呢，根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined。这里明显count 是函数内部的flag2 的那个count ，1234567891011var count=10;//全局作用域function add()&#123; //var count=0;注释掉了 return function()&#123; count+=1;//函数的内部作用域 alert(count); &#125;&#125;var s=add()s();//输出11s();//输出12 自然这是体现不出闭包的性质，只为了说明函数作用域链 继续说明：第一次执行，是没有疑问的输出1，那第二次的过程是怎样的呢？ 继续执行那个函数的返回的方法，还是count+=1;然后再输出count ，这里问题就来了，不应该继续向上寻找，找到count=0；然后输出1吗？不知道有没有注意一个问题，那就是s()执行的是下面这个函数1234function()&#123; count+=1;//函数的内部作用域 alert(count);&#125; 也就是说add()，只被执行了一次。然后执行两次s()，那count的值就是只声明了一次。var s=add()，函数add 只在这里执行了一次。下面执行的都是s()，那第二次的count的值是从哪儿来的，没错它还是第一次执行add时，留下来的那个变量。（这怎么可能，函数变量执行完就会被释放啊，为什么还在？这里就是一个垃圾回收机制的引用计数问题）。“”如果一个变量的引用不为0，那么他不会被垃圾回收机制回收，引用，就是被调用“”。由于再次执行s()的时候，再次引用了第一次add()产生的变量count ，所以count没有被释放，第一次s(),count 的值为1,第二次执行s()，count的值再加1，自然就是2了。让我们返回来再看看，根据以上所说，如果执行两次add() ，那就应该输出 都是1，来改一下这个函数 123456789function add()&#123; var count=0;//函数全局作用域 return function()&#123; count+=1;//函数的内部作用域 alert(count); &#125;&#125;add()();//输出1add()();//输出1 果真如此。输出的两次都是1.另外，我觉得阮一峰说的闭包也是很简洁的：“我的理解是，闭包就是能够读取其他函数内部变量的函数。” 变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。Js代码12345var n=999;function f1()&#123; alert(n);&#125;f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。Js代码 1234function f1()&#123; var n=999;&#125;alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！Js代码 12345function f1()&#123; n=999;&#125;f1();alert(n); // 999 有时候需要得到函数内的局部变量，在函数的内部，再定义一个函数。Js代码 123456function f1()&#123; n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值就可以在f1外部读取它的内部变量了。Js代码 123456789function f1()&#123; n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。Js代码123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 结语理解JavaScript的闭包是迈向高级JS程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://huayan.site/tags/Javascript/"},{"name":"闭包","slug":"闭包","permalink":"http://huayan.site/tags/闭包/"}]},{"title":"Vue2.x 服务端渲染入门","slug":"Vue服务端渲染入门","date":"2017-09-26T08:51:22.000Z","updated":"2017-09-26T08:41:17.000Z","comments":true,"path":"2017/09/26/Vue服务端渲染入门/","link":"","permalink":"http://huayan.site/2017/09/26/Vue服务端渲染入门/","excerpt":"","text":"什么是服务端渲染 SSRserver side render就是通过后端吐模板，而不是通过前端ajax获取数据，拼接字符串。 为什么需要SSR需要SEO，因为爬虫不会等待ajax结果。客户端网络慢，加载速度慢，影响用户体验。 另一种解决办法 预渲染不是一次性下载整个单页应用，预渲染只是在构建时为了特定的路由生成特定的几个静态页面你用webpack可以很简单地通过prerender-spa-plugin来添加预渲染 NodeJS编写Vue的SSR首先npm install –save-dev的有 vue express vue-server-renderer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// server.js'use strict';var fs = require('fs');var path = require('path');global.Vue = require('vue')var layout = fs.readFileSync('./index.html', 'utf8')var renderer = require('vue-server-renderer').createRenderer()var express = require('express')var server = express()server.use('/assets',express.static( path.resolve(__dirname,'assets')))server.get('*',function(req, res)&#123; // 将Vue实例渲染成HTML renderer.renderToString( // 创建一个应用实例 require('./assets/app')(), // 处理渲染结果 function(error, html)&#123; if(error)&#123; console.error(error); return res .status(500) .send('Server Error') &#125; // 发送布局和HTML文件 res.send(layout.replace('&lt;div id=\"app\"&gt;&lt;/div&gt;', html)) &#125; )&#125;)server.listen(5000, function(error)&#123; if(error) throw errorr; console.log('Server is running at localhost:5000')&#125;) 12345678910111213141516171819// index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script src=\"/assets/vue.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"/assets/app.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt;app.$mount('#app')&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"服务端渲染","slug":"服务端渲染","permalink":"http://huayan.site/tags/服务端渲染/"},{"name":"SSR","slug":"SSR","permalink":"http://huayan.site/tags/SSR/"}]},{"title":"模拟Vue.js双向绑定的实现","slug":"模拟Vue-js双向绑定的实现","date":"2017-06-17T14:08:46.000Z","updated":"2017-06-17T14:27:45.000Z","comments":true,"path":"2017/06/17/模拟Vue-js双向绑定的实现/","link":"","permalink":"http://huayan.site/2017/06/17/模拟Vue-js双向绑定的实现/","excerpt":"","text":"原文地址 Vue.js 最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。本文仅探究双向绑定是怎样实现的。先讲涉及的知识点，再用简化得不能再简化的代码实现一个简单的 hello world 示例。 参考文章：https://segmentfault.com/a/1190000006599500 一、访问器属性访问器属性是对象中的一种特殊属性，它不能直接在对象中设置，而必须通过 defineProperty() 方法单独定义。 123456var obj = &#123; &#125;;// 为obj定义一个名为 hello 的访问器属性Object.defineProperty(obj, \"hello\", &#123; get: function () &#123;return sth&#125;, set: function (val) &#123;/* do sth */&#125;&#125;) obj.hello // 可以像普通属性一样读取访问器属性 访问器属性的”值”比较特殊，读取或设置访问器属性的值，实际上是调用其内部特性：get和set函数。 obj.hello // 读取属性，就是调用get函数并返回get函数的返回值 obj.hello = “abc” // 为属性赋值，就是调用set函数，赋值其实是传参 get 和 set 方法内部的 this 都指向 obj，这意味着 get 和 set 函数可以操作对象内部的值。另外，访问器属性的会”覆盖”同名的普通属性，因为访问器属性会被优先访问，与其同名的普通属性则会被忽略。 二、极简双向绑定的实现 此例实现的效果是：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.hello 的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向绑定。 以上就是 Vue 实现双向绑定的基本原理。 三、分解任务上述示例仅仅是为了说明原理。我们最终要实现的是： 首先将该任务分成几个子任务： 输入框以及文本节点与 data 中的数据绑定 输入框内容变化时，data 中的数据同步变化。即 view =&gt; model 的变化。 data 中的数据变化时，文本节点的内容同步变化。即 model =&gt; view 的变化。 要实现任务一，需要对 DOM 进行编译，这里有一个知识点：DocumentFragment。 四、DocumentFragmentDocumentFragment（文档片段）可以看作节点容器，它可以包含多个子节点，当我们将它插入到 DOM 中时，只有它的子节点会插入目标节点，所以把它看作一组节点的容器。使用 DocumentFragment 处理节点，速度和性能远远优于直接操作 DOM。Vue 进行编译时，就是将挂载目标的所有子节点劫持（真的是劫持，通过 append 方法，DOM 中的节点会被自动删除）到 DocumentFragment 中，经过一番处理后，再将 DocumentFragment 整体返回插入挂载目标。 #勘误：flag.append() 应为 flag.appendChild()。下同。在 Chrome 中用 append() 竟然正常，没报错。 五、数据初始化绑定 以上代码实现了任务一，我们可以看到，hello world已经呈现在输入框和文本节点中。 六、响应式的数据绑定再来看任务二的实现思路：当我们在输入框输入数据的时候，首先触发 input 事件（或者 keyup、change 事件），在相应的事件处理程序中，我们获取输入框的 value 并赋值给 vm 实例的 text 属性。我们会利用 defineProperty 将 data 中的 text 设置为 vm 的访问器属性，因此给 vm.text 赋值，就会触发 set 方法。在 set 方法中主要做两件事，第一是更新属性的值，第二留到任务三再说。 任务二也就完成了，text 属性值会与输入框的内容同步变化： 七、订阅/发布模式（subscribe&amp;publish）text 属性变化了，set 方法触发了，但是文本节点的内容没有变化。如何让同样绑定到 text 的文本节点也同步变化呢？这里又有一个知识点：订阅发布模式。 订阅发布模式（又称观察者模式）定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象。 发布者发出通知 =&gt; 主题对象收到通知并推送给订阅者 =&gt; 订阅者执行相应操作 之前提到的，当 set 方法触发后做的第二件事就是作为发布者发出通知：“我是属性 text，我变了”。文本节点则是作为订阅者，在收到消息后执行相应的更新操作。 八、双向绑定的实现回顾一下，每当 new 一个 Vue，主要做了两件事：第一个是监听数据：observe(data)，第二个是编译 HTML：nodeToFragement(id)。 在监听数据的过程中，会为 data 中的每一个属性生成一个主题对象 dep。 在编译 HTML 的过程中，会为每个与数据绑定相关的节点生成一个订阅者 watcher，watcher 会将自己添加到相应属性的 dep 中。 我们已经实现：修改输入框内容 =&gt; 在事件回调函数中修改属性值 =&gt; 触发属性的 set 方法。 接下来我们要实现的是：发出通知 dep.notify() =&gt; 触发订阅者的 update 方法 =&gt; 更新视图。 这里的关键逻辑是：如何将 watcher 添加到关联属性的 dep 中。 在编译 HTML 过程中，为每个与 data 关联的节点生成一个 Watcher。Watcher 函数中发生了什么呢？ 首先，将自己赋给了一个全局变量 Dep.target； 其次，执行了 update 方法，进而执行了 get 方法，get 的方法读取了 vm 的访问器属性，从而触发了访问器属性的 get 方法，get 方法中将该 watcher 添加到了对应访问器属性的 dep 中； 再次，获取属性的值，然后更新视图。 最后，将 Dep.target 设为空。因为它是全局变量，也是 watcher 与 dep 关联的唯一桥梁，任何时刻都必须保证 Dep.target 只有一个值。 至此，hello world 双向绑定就基本实现了。文本内容会随输入框内容同步变化，在控制器中修改 vm.text 的值，会同步反映到文本内容中。 完整代码：https://github.com/bison1994/two-way-data-binding 更详尽的源码分析，可以参考滴滴的这篇文章：https://github.com/DDFE/DDFE-blog/issues/7","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://huayan.site/tags/javascript/"},{"name":"双向绑定","slug":"双向绑定","permalink":"http://huayan.site/tags/双向绑定/"},{"name":"Vue","slug":"Vue","permalink":"http://huayan.site/tags/Vue/"}]},{"title":"神秘的属性描述符","slug":"神秘的属性描述符","date":"2017-06-16T01:59:52.000Z","updated":"2017-06-16T03:17:15.000Z","comments":true,"path":"2017/06/16/神秘的属性描述符/","link":"","permalink":"http://huayan.site/2017/06/16/神秘的属性描述符/","excerpt":"","text":"http://www.cnblogs.com/xiaohuochai/p/5743821.html 前面的话对于操作系统中的文件，我们可以驾轻就熟将其设置为只读、隐藏、系统文件或普通文件。于对象来说，属性描述符提供类似的功能，用来描述对象的值、是否可配置、是否可修改以及是否可枚举。本文就来介绍对象中神秘的属性描述符 描述符类型 对象属性描述符的类型分为两种：数据属性和访问器属性 数据属性数据属性(data property)包含一个数据值的位置，在这个位置可以读取和写入值。数据属性有4个特性 Configurable(可配置性) 可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true Enumerable(可枚举性) 可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true Writable(可写性) 可写性决定是否可以修改属性的值，默认值为true Value(属性值) 属性值包含这个属性的数据值，读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为undefined 访问器属性对象属性是名字、值和一组属性描述符构成的。而属性值可以用一个或两个方法替代，这两个方法就是getter和setter。而这种属性类型叫访问器属性(accessor property) Configurable(可配置性) 可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true Enumerable(可枚举性) 可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true getter 在读取属性时调用的函数。默认值为undefined setter 在写入属性时调用的函数。默认值为undefined 和数据属性不同，访问器属性不具有可写性(Writable)。如果属性同时具有getter和setter方法，那么它是一个读/写属性。如果它只有getter方法，那么它是一个只读属性。如果它只有setter方法，那么它是一个只写属性。读取只写属性总是返回undefined 描述符方法 前面介绍了属性描述符，要想设置它们，就需要用到描述符方法。描述符方法总共有以下4个： Object.getOwnPropertyDescriptor() Object.getOwnPropertyDescriptor(o,name)方法用于查询一个属性的描述符，并以对象的形式返回 查询obj.a属性时，可配置性、可枚举性、可写性都是默认的true，而value是a的属性值1 查询obj.b属性时，因为obj.b属性不存在，该方法返回undefined 12345var obj = &#123;a:1&#125;;//Object &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(obj,'a'));//undefinedconsole.log(Object.getOwnPropertyDescriptor(obj,'b')); Object.defineProperty() Object.defineProperty(o,name,desc)方法用于创建或配置对象的一个属性的描述符，返回配置后的对象 使用该方法创建或配置对象属性的描述符时，如果不针对该属性进行描述符的配置，则该项描述符默认为false 12345678910var obj = &#123;&#125;;//&#123;a:1&#125;console.log(Object.defineProperty(obj,'a',&#123; value:1, writable: true &#125;));//由于没有配置enumerable和configurable，所以它们的值为false//&#123;value: 1, writable: true, enumerable: false, configurable: false&#125;console.log(Object.getOwnPropertyDescriptor(obj,'a')); Object.defineProperties() Object.defineProperty(o,descriptors)方法用于创建或配置对象的多个属性的描述符，返回配置后的对象 12345678910111213var obj = &#123; a:1&#125;;//&#123;a: 1, b: 2&#125;console.log(Object.defineProperties(obj,&#123; a:&#123;writable:false&#125;, b:&#123;value:2&#125; &#125;));//&#123;value: 1, writable: false, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(obj,'a'));//&#123;value: 2, writable: false, enumerable: false, configurable: false&#125;console.log(Object.getOwnPropertyDescriptor(obj,'b')); Object.create() Object.create(proto,descriptors)方法使用指定的原型和属性来创建一个对象 12345var o = Object.create(Object.prototype,&#123; a:&#123;writable: false,value:1,enumerable:true&#125;&#125;);//&#123;value: 1, writable: false, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(obj,'a')); 描述符详述 前面分别介绍了数据属性和访问器属性的描述符，但没有详细说明其含义及使用，接下来逐一进行说明 可写性(writable)可写性决定是否可以修改属性的值，默认值为true1234var o = &#123;a:1&#125;;o.a = 2;console.log(o.a);//2 设置writable:false后，赋值语句会静默失效 1234567891011121314var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; writable:false&#125;);console.log(o.a);//1//由于设置了writable为false，所以o.a=2这个语句会静默失效o.a = 2;console.log(o.a);//1Object.defineProperty(o,'a',&#123; writable:true&#125;);//由于writable设置为true，所以o.a可以被修改为2o.a = 2;console.log(o.a);//2 在严格模式下通过赋值语句为writable为false的属性赋值，会提示类型错误TypeError 1234567'use strict';var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; writable:false&#125;);//Uncaught TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'o.a = 2; [注意]设置writable:false后，通过Object.defineProperty()方法改变属性value的值不会受影响，因为这也意味着在重置writable的属性值为false 123456789var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; writable:false&#125;);console.log(o.a);//1Object.defineProperty(o,'a',&#123; value:2&#125;);console.log(o.a);//2 可配置性(Configurable) 可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true 设置Configurable:false后，无法使用delete删除属性123456var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; configurable:false&#125;);delete o.a;//falseconsole.log(o.a);//1 在严格模式下删除为configurable为false的属性，会提示类型错误TypeError 1234567'use strict';var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; configurable:false&#125;);//Uncaught TypeError: Cannot delete property 'a' of #&lt;Object&gt;delete o.a; [注意]使用var命令声明变量时，变量的configurable为false 123var a = 1;//&#123;value: 1, writable: true, enumerable: true, configurable: false&#125;Object.getOwnPropertyDescriptor(this,'a'); 一般地，设置Configurable:false后，将无法再使用defineProperty()方法来修改属性描述符 12345678var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; configurable:false&#125;);//Uncaught TypeError: Cannot redefine property: aObject.defineProperty(o,'a',&#123; configurable:true&#125;); 有一个例外，设置Configurable:false后，只允许writable的状态从true变为false 12345678910111213var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; configurable:false, writable:true&#125;);o.a = 2;console.log(o.a);//2Object.defineProperty(o,'a',&#123; writable:false&#125;);//由于writable:false生效，对象a的o属性无法修改值，所以o.a=3的赋值语句静默失败o.a = 3;console.log(o.a);//2 可枚举性(Enumerable) 可枚举性决定属性是否出现在对象的属性枚举中，具体来说，for-in循环、Object.keys方法、JSON.stringify方法是否会取到该属性 用户定义的普通属性默认是可枚举的，而原生继承的属性默认是不可枚举的12345//由于原生继承的属性默认不可枚举，所以只取得自定义的属性a:1var o = &#123;a:1&#125;;for(var i in o)&#123; console.log(o[i]);//1&#125; 123456//由于enumerable被设置为false，在for-in循环中a属性无法被枚举出来var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123;enumerable:false&#125;);for(var i in o)&#123; console.log(o[i]);//undefined&#125; propertyIsEnumerable() propertyIsEnumerable()方法用于判断对象的属性是否可枚举1234var o = &#123;a:1&#125;;console.log(o.propertyIsEnumerable('a'));//trueObject.defineProperty(o,'a',&#123;enumerable:false&#125;);console.log(o.propertyIsEnumerable('a'));//false get和set get是一个隐藏函数，在获取属性值时调用。set也是一个隐藏函数，在设置属性值时调用，它们的默认值都是undefined。Object.definedProperty()中的get和set对应于对象字面量中get和set方法 [注意]getter和setter取代了数据属性中的value和writable属性 给只设置get方法，没有设置set方法的对象赋值会静默失败，在严格模式下会报错 123456789var o = &#123; get a()&#123; return 2; &#125;&#125; console.log(o.a);//2//由于没有设置set方法，所以o.a=3的赋值语句会静默失败o.a = 3;console.log(o.a);//2 123456789Object.defineProperty(o,'a',&#123; get: function()&#123; return 2; &#125;&#125;)console.log(o.a);//2//由于没有设置set方法，所以o.a=3的赋值语句会静默失败o.a = 3;console.log(o.a);//2 在严格模式下，给没有设置set方法的访问器属性赋值会报错 12345678910'use strict';var o = &#123; get a()&#123; return 2; &#125;&#125; console.log(o.a);//2//由于没有设置set方法，所以o.a=3的赋值语句会报错//Uncaught TypeError: Cannot set property a of #&lt;Object&gt; which has only a gettero.a = 3; 12345678910'use strict';Object.defineProperty(o,'a',&#123; get: function()&#123; return 2; &#125;&#125;)console.log(o.a);//2//由于没有设置set方法，所以o.a=3的赋值语句会报错//Uncaught TypeError: Cannot set property a of #&lt;Object&gt; which has only a gettero.a = 3; 只设置set方法，而不设置get方法，则对象属性值为undefined 1234567var o = &#123; set a(val)&#123; return 2; &#125;&#125; o.a = 1;console.log(o.a);//undefined 1234567Object.defineProperty(o,'a',&#123; set: function()&#123; return 2; &#125;&#125;)o.a = 1;console.log(o.a);//undefined 一般地，set和get方法是成对出现的 12345678910var o =&#123; get a()&#123; return this._a; &#125;, set a(val)&#123; this._a = val*2; &#125;&#125;o.a = 1;console.log(o.a);//2 12345678910Object.defineProperty(o,'a',&#123; get: function()&#123; return this._a; &#125;, set :function(val)&#123; this._a = val*2; &#125;&#125;)o.a = 1;console.log(o.a);//2 对象状态属性描述符只能用来控制对象中一个属性的状态。而如果要控制对象的状态，就要用到下面的6种方法 Object.preventExtensions()(禁止扩展) Object.preventExtensions()方法使一个对象无法再添加新的属性，并返回当前对象 Object.isExtensible()(测试扩展) Object.isExtensible()方法用来检测该对象是否可以扩展 123456789var o = &#123;a:1&#125;;console.log(Object.isExtensible(o));//trueo.b = 2;console.log(o);//&#123;a: 1, b: 2&#125;console.log(Object.preventExtensions(o));//&#123;a: 1, b: 2&#125;//由于对象o禁止扩展，所以该赋值语句静默失败o.c = 3;console.log(Object.isExtensible(o));//falseconsole.log(o);//&#123;a: 1, b: 2&#125; 在严格模式下，给禁止扩展的对象添加属性会报TypeError错误 12345'use strict';var o = &#123;a:1&#125;;console.log(Object.preventExtensions(o));//&#123;a:1&#125;//Uncaught TypeError: Can't add property c, object is not extensibleo.c = 3; Object.preventExtensions()方法并不改变对象中属性的描述符状态 123456var o = &#123;a:1&#125;;//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(o,'a'));Object.preventExtensions(o);//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(o,'a')); Object.seal()(对象封印) 对象封印又叫对象密封，使一个对象不可扩展并且所有属性不可配置，并返回当前对象 Object.isSealed()(测试封印) Object.isSealed()方法用来检测该方法是否被封印 1234567var o = &#123;a:1,b:2&#125;;console.log(Object.isSealed(o));//falseconsole.log(Object.seal(o));//&#123;a:1,b:2&#125;console.log(Object.isSealed(o));//trueconsole.log(delete o.b);//falseo.c = 3;console.log(o);//&#123;a:1,b:2&#125; 在严格模式下，删除旧属性或添加新属性都会报错 12345'use strict';var o = &#123;a:1,b:2&#125;;console.log(Object.seal(o));//&#123;a:1,b:2&#125;//Uncaught TypeError: Cannot delete property 'b' of #&lt;Object&gt;delete o.b; 这个方法实际上会在现有对象上调用Object.preventExtensions()方法，并把所有现有属性的configurable描述符置为false 123456var o = &#123;a:1,b:2&#125;;//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(o,'a'));console.log(Object.seal(o));//&#123;a:1,b:2&#125;//&#123;value: 1, writable: true, enumerable: true, configurable: false&#125;console.log(Object.getOwnPropertyDescriptor(o,'a')); Object.freeze()(对象冻结) Object.freeze()方法使一个对象不可扩展，不可配置，也不可改写，变成一个仅可以枚举的只读常量，并返回当前对象 Object.isFrozen()(检测冻结) Object.isFrozen()方法用来检测一个对象是否被冻结 123456var o = &#123;a:1,b:2&#125;;console.log(Object.isFrozen(o));//falseconsole.log(Object.freeze(o));//&#123;a:1,b:2&#125;console.log(Object.isFrozen(o));//trueo.a = 3;console.log(o);//&#123;a:1,b:2&#125; 在严格模式下，删除旧属性、添加新属性、更改现有属性都会报错 12345'use strict';var o = &#123;a:1,b:2&#125;;console.log(Object.freeze(o));//&#123;a:1,b:2&#125;//Uncaught TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'o.a = 3; 这个方法实际上会在现有对象上调用Object.seal()方法，并把所有现有属性的writable描述符置为false 123456var o = &#123;a:1&#125;;//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(o,'a'));console.log(Object.freeze(o));//&#123;a:1&#125;//&#123;value: 1, writable: false, enumerable: true, configurable: false&#125;console.log(Object.getOwnPropertyDescriptor(o,'a'));","categories":[],"tags":[{"name":"双向绑定","slug":"双向绑定","permalink":"http://huayan.site/tags/双向绑定/"},{"name":"属性访问器","slug":"属性访问器","permalink":"http://huayan.site/tags/属性访问器/"}]},{"title":"Javascript角度理解发布订阅者模式","slug":"Javascript角度理解发布订阅者模式","date":"2017-06-14T08:51:22.000Z","updated":"2017-06-15T03:37:42.000Z","comments":true,"path":"2017/06/14/Javascript角度理解发布订阅者模式/","link":"","permalink":"http://huayan.site/2017/06/14/Javascript角度理解发布订阅者模式/","excerpt":"","text":"原文地址 发布订阅模式介绍 发布订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 现实生活中的发布-订阅模式；比如小红最近在淘宝网上看上一双鞋子，但是呢 联系到卖家后，才发现这双鞋卖光了，但是小红对这双鞋又非常喜欢，所以呢联系卖家，问卖家什么时候有货，卖家告诉她，要等一个星期后才有货，卖家告诉小红，要是你喜欢的话，你可以收藏我们的店铺，等有货的时候再通知你，所以小红收藏了此店铺，但与此同时，小明，小花等也喜欢这双鞋，也收藏了该店铺；等来货的时候就依次会通知他们； 在上面的故事中，可以看出是一个典型的发布订阅模式，卖家是属于发布者，小红，小明等属于订阅者，订阅该店铺，卖家作为发布者，当鞋子到了的时候，会依次通知小明，小红等，依次使用旺旺等工具给他们发布消息； 发布订阅模式的优点： 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。比如上面的列子，小明，小红不需要天天逛淘宝网看鞋子到了没有，在合适的时间点，发布者(卖家)来货了的时候，会通知该订阅者(小红，小明等人)。 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变；同理卖家（发布者）它只需要将鞋子来货的这件事告诉订阅者(买家)，他不管买家到底买还是不买，还是买其他卖家的。只要鞋子到货了就通知订阅者即可。 对于第一点，我们日常工作中也经常使用到，比如我们的ajax请求，请求有成功(success)和失败(error)的回调函数，我们可以订阅ajax的success和error事件。我们并不关心对象在异步运行的状态，我们只关心success的时候或者error的时候我们要做点我们自己的事情就可以了~ 发布订阅模式的缺点： 创建订阅者需要消耗一定的时间和内存。 虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等 如何实现发布–订阅模式？ 首先要想好谁是发布者(比如上面的卖家)。 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。 最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 我们还可以在回调函数里面添加一点参数，比如鞋子的颜色，鞋子尺码等信息； 我们先来实现下简单的发布-订阅模式；代码如下：123456789101112131415161718192021222324252627var shoeObj = &#123;&#125;; // 定义发布者shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者shoeObj.listen = function(fn) &#123; shoeObj.list.push(fn); // 订阅消息添加到缓存列表&#125;// 发布消息shoeObj.trigger = function()&#123; for(var i = 0,fn; fn = this.list[i++];) &#123; fn.apply(this,arguments); &#125;&#125;// 小红订阅如下消息shoeObj.listen(function(color,size)&#123; console.log(\"颜色是：\"+color); console.log(\"尺码是：\"+size); &#125;);// 小花订阅如下消息shoeObj.listen(function(color,size)&#123; console.log(\"再次打印颜色是：\"+color); console.log(\"再次打印尺码是：\"+size); &#125;);shoeObj.trigger(\"红色\",40);shoeObj.trigger(\"黑色\",42); 打印如上截图，我们看到订阅者接收到发布者的每个消息，但是呢，对于小红来说，她只想接收颜色为红色的消息，不想接收颜色为黑色的消息，为此我们需要对代码进行如下改造下，我们可以先增加一个key，使订阅者只订阅自己感兴趣的消息。 12345678910111213141516171819202122232425262728293031323334353637var shoeObj = &#123;&#125;; // 定义发布者shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者shoeObj.listen = function(key,fn) &#123; if(!this.list[key]) &#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表 this.list[key] = []; &#125; this.list[key].push(fn); // 订阅消息添加到缓存列表&#125;// 发布消息shoeObj.trigger = function()&#123; var key = Array.prototype.shift.call(arguments); // 取出消息类型名称 var fns = this.list[key]; // 取出该消息对应的回调函数的集合 // 如果没有订阅过该消息的话，则返回 if(!fns || fns.length === 0) &#123; return; &#125; for(var i = 0,fn; fn = fns[i++]; ) &#123; fn.apply(this,arguments); // arguments 是发布消息时附送的参数 &#125;&#125;;// 小红订阅如下消息shoeObj.listen('red',function(size)&#123; console.log(\"尺码是：\"+size); &#125;);// 小花订阅如下消息shoeObj.listen('block',function(size)&#123; console.log(\"再次打印尺码是：\"+size); &#125;);shoeObj.trigger(\"red\",40);shoeObj.trigger(\"block\",42); 上面的代码，我们再来运行打印下 如下：可以看到，订阅者只订阅自己感兴趣的消息了； 发布—订阅模式的代码封装我们知道，对于上面的代码，小红去买鞋这么一个对象shoeObj 进行订阅，但是如果以后我们需要对买房子或者其他的对象进行订阅呢，我们需要复制上面的代码，再重新改下里面的对象代码；为此我们需要进行代码封装； 如下代码封装：123456789101112131415161718192021var event = &#123; list: [], listen: function(key,fn) &#123; if(!this.list[key]) &#123; this.list[key] = []; &#125; // 订阅的消息添加到缓存列表中 this.list[key].push(fn); &#125;, trigger: function()&#123; var key = Array.prototype.shift.call(arguments); var fns = this.list[key]; // 如果没有订阅过该消息的话，则返回 if(!fns || fns.length === 0) &#123; return; &#125; for(var i = 0,fn; fn = fns[i++];) &#123; fn.apply(this,arguments); &#125; &#125;&#125;; 我们在定义一个initEvent函数，这个函数使所有的普通对象都具有发布订阅功能，如下代码： 123456789101112131415161718192021var initEvent = function(obj) &#123; for(var i in event) &#123; obj[i] = event[i]; &#125;&#125;;// 我们再来测试下，我们还是给shoeObj这个对象添加发布-订阅功能；var shoeObj = &#123;&#125;;initEvent(shoeObj);// 小红订阅如下消息shoeObj.listen('red',function(size)&#123; console.log(\"尺码是：\"+size); &#125;);// 小花订阅如下消息shoeObj.listen('block',function(size)&#123; console.log(\"再次打印尺码是：\"+size); &#125;);shoeObj.trigger(\"red\",40);shoeObj.trigger(\"block\",42); 如何取消订阅事件？比如上面的列子，小红她突然不想买鞋子了，那么对于卖家的店铺他不想再接受该店铺的消息，那么小红可以取消该店铺的订阅。 如下代码：123456789101112131415161718event.remove = function(key,fn)&#123; var fns = this.list[key]; // 如果key对应的消息没有订阅过的话，则返回 if(!fns) &#123; return false; &#125; // 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅 if(!fn) &#123; fn &amp;&amp; (fns.length = 0); &#125;else &#123; for(var i = fns.length - 1; i &gt;= 0; i--) &#123; var _fn = fns[i]; if(_fn === fn) &#123; fns.splice(i,1); // 删除订阅者的回调函数 &#125; &#125; &#125;&#125;; 测试代码如下：12345678910111213141516171819var initEvent = function(obj) &#123; for(var i in event) &#123; obj[i] = event[i]; &#125;&#125;;var shoeObj = &#123;&#125;;initEvent(shoeObj);// 小红订阅如下消息shoeObj.listen('red',fn1 = function(size)&#123; console.log(\"尺码是：\"+size); &#125;);// 小花订阅如下消息shoeObj.listen('red',fn2 = function(size)&#123; console.log(\"再次打印尺码是：\"+size); &#125;);shoeObj.remove(\"red\",fn1);shoeObj.trigger(\"red\",42); 运行结果如下： 全局–发布订阅对象代码封装我们再来看看我们传统的ajax请求吧，比如我们传统的ajax请求，请求成功后需要做如下事情： 渲染数据。 使用数据来做一个动画。 那么我们以前肯定是如下写代码：1234$.ajax(“http://127.0.0.1/index.php”,function(data)&#123; rendedData(data); // 渲染数据 doAnimate(data); // 实现动画 &#125;); 假如以后还需要做点事情的话，我们还需要在里面写调用的方法；这样代码就耦合性很高，那么我们现在使用发布-订阅模式来看如何重构上面的业务需求代码； 1234567891011$.ajax(“http://127.0.0.1/index.php”,function(data)&#123; Obj.trigger(‘success’,data); // 发布请求成功后的消息&#125;);// 下面我们来订阅此消息，比如我现在订阅渲染数据这个消息；Obj.listen(“success”,function(data)&#123; renderData(data);&#125;);// 订阅动画这个消息Obj.listen(“success”,function(data)&#123; doAnimate(data); &#125;); 为此我们可以封装一个全局发布-订阅模式对象；如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var Event = (function()&#123; var list = &#123;&#125;, listen, trigger, remove; listen = function(key,fn)&#123; if(!list[key]) &#123; list[key] = []; &#125; list[key].push(fn); &#125;; trigger = function()&#123; var key = Array.prototype.shift.call(arguments), fns = list[key]; if(!fns || fns.length === 0) &#123; return false; &#125; for(var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this,arguments); &#125; &#125;; remove = function(key,fn)&#123; var fns = list[key]; if(!fns) &#123; return false; &#125; if(!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125;else &#123; for(var i = fns.length - 1; i &gt;= 0; i--)&#123; var _fn = fns[i]; if(_fn === fn) &#123; fns.splice(i,1); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;&#125;)();// 测试代码如下：Event.listen(\"color\",function(size) &#123; console.log(\"尺码为:\"+size); // 打印出尺码为42&#125;);Event.trigger(\"color\",42); 理解模块间通信我们使用上面封装的全局的发布-订阅对象来实现两个模块之间的通信问题；比如现在有一个页面有一个按钮，每次点击此按钮后，div中会显示此按钮被点击的总次数；如下代码：12&lt;button id=\"count\"&gt;点将我&lt;/button&gt;&lt;div id=\"showcount\"&gt;&lt;/div&gt; 我们中的a.js 负责处理点击操作 及 发布消息；如下JS代码：1234567var a = (function()&#123; var count = 0; var button = document.getElementById(\"count\"); button.onclick = function()&#123; Event.trigger(\"add\",count++); &#125;&#125;)(); b.js 负责监听add这个消息，并把点击的总次数显示到页面上来；如下代码：123456var b = (function()&#123; var div = document.getElementById(\"showcount\"); Event.listen('add',function(count)&#123; div.innerHTML = count; &#125;);&#125;)(); 下面是html代码如下，JS应用如下引用即可：1234567891011121314&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"global.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"count\"&gt;点将我&lt;/button&gt; &lt;div id=\"showcount\"&gt;&lt;/div&gt; &lt;script src = \"a.js\"&gt;&lt;/script&gt; &lt;script src = \"b.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如上代码，当点击一次按钮后，showcount的div会自动加1，如上演示的是2个模块之间如何使用发布-订阅模式之间的通信问题； 其中global.js 就是我们上面封装的全局-发布订阅模式对象的封装代码；","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://huayan.site/tags/设计模式/"}]},{"title":"JavaScript深入之从原型到原型链","slug":"JavaScript深入之从原型到原型链","date":"2017-05-21T08:51:22.000Z","updated":"2017-06-03T16:12:41.000Z","comments":true,"path":"2017/05/21/JavaScript深入之从原型到原型链/","link":"","permalink":"http://huayan.site/2017/05/21/JavaScript深入之从原型到原型链/","excerpt":"","text":"JavaScript深入之从原型到原型链原文出处： 冴羽 JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。 构造函数创建对象我们先使用构造函数创建一个对象： 123456function Person() &#123;&#125;var person = new Person();person.name = 'Kevin';console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： 12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = 'Kevin';var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 构造函数和实例原型的关系图 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： __proto__这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 实例与实例原型的关系图 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor ，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 实例原型与构造函数的关系图 综上我们已经得出： 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 12345678910111213function Person() &#123;&#125;Person.prototype.name = 'Kevin';var person = new Person();person.name = 'Daisy';console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = 'Kevin'console.log(obj.name) // Kevin 所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型的原型关系图 原型链那 Object.prototype 的原型呢？ null，不信我们可以打印： 1console.log(Object.prototype.__proto__ === null) // true 所以查到属性的时候查到 Object.prototype 就可以停止查找了。 所以最后一张关系图就是 原型链示意图 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor首先是 constructor 属性，我们看个例子： 12345function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： 1person.constructor === Person.prototype.constructor __proto__其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 下一篇文章JavaScript深入之词法作用域和动态作用域 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[{"name":"原型","slug":"原型","permalink":"http://huayan.site/tags/原型/"},{"name":"原型链","slug":"原型链","permalink":"http://huayan.site/tags/原型链/"},{"name":"prototype","slug":"prototype","permalink":"http://huayan.site/tags/prototype/"}]},{"title":"JavaScript 面试中常见算法问题详解","slug":"JavaScript-面试中常见算法问题详解","date":"2017-05-15T08:51:22.000Z","updated":"2017-05-17T13:28:43.000Z","comments":true,"path":"2017/05/15/JavaScript-面试中常见算法问题详解/","link":"","permalink":"http://huayan.site/2017/05/15/JavaScript-面试中常见算法问题详解/","excerpt":"","text":"原文出处：王下邀月熊_Chevalier JavaScript Specification阐述下 JavaScript 中的变量提升所谓提升，顾名思义即是 JavaScript 会将所有的声明提升到当前作用域的顶部。这也就意味着我们可以在某个变量声明前就使用该变量，不过虽然 JavaScript 会将声明提升到顶部，但是并不会执行真的初始化过程。 阐述下 use strict; 的作用use strict; 顾名思义也就是 JavaScript 会在所谓严格模式下执行，其一个主要的优势在于能够强制开发者避免使用未声明的变量。对于老版本的浏览器或者执行引擎则会自动忽略该指令。 12345678// Example of strict mode\"use strict\";catchThemAll();function catchThemAll() &#123; x = 3.14; // Error will be thrown return x * x;&#125; 解释下什么是 Event Bubbling 以及如何避免Event Bubbling 即指某个事件不仅会触发当前元素，还会以嵌套顺序传递到父元素中。直观而言就是对于某个子元素的点击事件同样会被父元素的点击事件处理器捕获。避免 Event Bubbling 的方式可以使用event.stopPropagation() 或者 IE 9 以下使用event.cancelBubble。 == 与 === 的区别是什么=== 也就是所谓的严格比较，关键的区别在于=== 会同时比较类型与值，而不是仅比较值。123456// Example of comparators0 == false; // true0 === false; // false2 == &apos;2&apos;; // true2 === &apos;2&apos;; // false 解释下 null 与 undefined 的区别JavaScript 中，null 是一个可以被分配的值，设置为 null 的变量意味着其无值。而 undefined 则代表着某个变量虽然声明了但是尚未进行过任何赋值。 解释下 Prototypal Inheritance 与 Classical Inheritance 的区别在类继承中，类是不可变的，不同的语言中对于多继承的支持也不一样，有些语言中还支持接口、final、abstract 的概念。而原型继承则更为灵活，原型本身是可以可变的，并且对象可能继承自多个原型。 数组找出整型数组中乘积最大的三个数给定一个包含整数的无序数组，要求找出乘积最大的三个数。 12345678910111213141516171819202122232425var unsorted_array = [-10, 7, 29, 30, 5, -10, -70];computeProduct(unsorted_array); // 21000function sortIntegers(a, b) &#123; return a - b;&#125;// greatest product is either (min1 * min2 * max1 || max1 * max2 * max3)function computeProduct(unsorted) &#123; var sorted_array = unsorted.sort(sortIntegers), product1 = 1, product2 = 1, array_n_element = sorted_array.length - 1; // Get the product of three largest integers in sorted array for (var x = array_n_element; x &gt; array_n_element - 3; x--) &#123; product1 = product1 * sorted_array[x]; &#125; product2 = sorted_array[0] * sorted_array[1] * sorted_array[array_n_element]; if (product1 &gt; product2) return product1; return product2&#125;; 寻找连续数组中的缺失数 给定某无序数组，其包含了 n 个连续数字中的 n - 1 个，已知上下边界，要求以O(n)的复杂度找出缺失的数字。 123456789101112131415161718192021222324252627// The output of the function should be 8var array_of_integers = [2, 5, 1, 4, 9, 6, 3, 7];var upper_bound = 9;var lower_bound = 1;findMissingNumber(array_of_integers, upper_bound, lower_bound); //8function findMissingNumber(array_of_integers, upper_bound, lower_bound) &#123; // Iterate through array to find the sum of the numbers var sum_of_integers = 0; for (var i = 0; i &lt; array_of_integers.length; i++) &#123; sum_of_integers += array_of_integers[i]; &#125; // 以高斯求和公式计算理论上的数组和 // Formula: [(N * (N + 1)) / 2] - [(M * (M - 1)) / 2]; // N is the upper bound and M is the lower bound upper_limit_sum = (upper_bound * (upper_bound + 1)) / 2; lower_limit_sum = (lower_bound * (lower_bound - 1)) / 2; theoretical_sum = upper_limit_sum - lower_limit_sum; // return (theoretical_sum - sum_of_integers)&#125; 数组去重 给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。1234567891011121314151617181920212223// ES6 Implementationvar array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]// ES5 Implementationvar array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];uniqueArray(array); // [1, 2, 3, 5, 9, 8]function uniqueArray(array) &#123; var hashmap = &#123;&#125;; var unique = []; for(var i = 0; i &lt; array.length; i++) &#123; // If key returns null (unique), it is evaluated as false. if(!hashmap.hasOwnProperty([array[i]])) &#123; hashmap[array[i]] = 1; unique.push(array[i]); &#125; &#125; return unique;&#125; 数组中元素最大差值计算 给定某无序数组，求取任意两个元素之间的最大差值，注意，这里要求差值计算中较小的元素下标必须小于较大元素的下标。譬如[7, 8, 4, 9, 9, 15, 3, 1, 10]这个数组的计算值是 11( 15 - 4 ) 而不是 14(15 - 1)，因为 15 的下标小于 1。 123456789101112131415161718192021222324252627282930313233var array = [7, 8, 4, 9, 9, 15, 3, 1, 10];// [7, 8, 4, 9, 9, 15, 3, 1, 10] would return `11` based on the difference between `4` and `15`// Notice: It is not `14` from the difference between `15` and `1` because 15 comes before 1.findLargestDifference(array);function findLargestDifference(array) &#123; // 如果数组仅有一个元素，则直接返回 -1 if (array.length &lt;= 1) return -1; // current_min 指向当前的最小值 var current_min = array[0]; var current_max_difference = 0; // 遍历整个数组以求取当前最大差值，如果发现某个最大差值，则将新的值覆盖 current_max_difference // 同时也会追踪当前数组中的最小值，从而保证 `largest value in future` - `smallest value before it` for (var i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; current_min &amp;&amp; (array[i] - current_min &gt; current_max_difference)) &#123; current_max_difference = array[i] - current_min; &#125; else if (array[i] &lt;= current_min) &#123; current_min = array[i]; &#125; &#125; // If negative or 0, there is no largest difference if (current_max_difference &lt;= 0) return -1; return current_max_difference;&#125; 数组中元素乘积 给定某无序数组，要求返回新数组 output ，其中 output[i] 为原数组中除了下标为 i 的元素之外的元素乘积，要求以 O(n) 复杂度实现： 1234567891011121314151617181920212223242526272829303132var firstArray = [2, 2, 4, 1];var secondArray = [0, 0, 0, 2];var thirdArray = [-2, -2, -3, 2];productExceptSelf(firstArray); // [8, 8, 4, 16]productExceptSelf(secondArray); // [0, 0, 0, 0]productExceptSelf(thirdArray); // [12, 12, 8, -12]function productExceptSelf(numArray) &#123; var product = 1; var size = numArray.length; var output = []; // From first array: [1, 2, 4, 16] // The last number in this case is already in the right spot (allows for us) // to just multiply by 1 in the next step. // This step essentially gets the product to the left of the index at index + 1 for (var x = 0; x &lt; size; x++) &#123; output.push(product); product = product * numArray[x]; &#125; // From the back, we multiply the current output element (which represents the product // on the left of the index, and multiplies it by the product on the right of the element) var product = 1; for (var i = size - 1; i &gt; -1; i--) &#123; output[i] = output[i] * product; product = product * numArray[i]; &#125; return output;&#125; 数组交集 给定两个数组，要求求出两个数组的交集，注意，交集中的元素应该是唯一的。 1234567891011121314151617181920212223242526272829var firstArray = [2, 2, 4, 1];var secondArray = [1, 2, 0, 2];intersection(firstArray, secondArray); // [2, 1]function intersection(firstArray, secondArray) &#123; // The logic here is to create a hashmap with the elements of the firstArray as the keys. // After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash // If it does exist, add that element to the new array. var hashmap = &#123;&#125;; var intersectionArray = []; firstArray.forEach(function(element) &#123; hashmap[element] = 1; &#125;); // Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added secondArray.forEach(function(element) &#123; if (hashmap[element] === 1) &#123; intersectionArray.push(element); hashmap[element]++; &#125; &#125;); return intersectionArray; // Time complexity O(n), Space complexity O(n)&#125; 字符串 颠倒字符串给定某个字符串，要求将其中单词倒转之后然后输出，譬如”Welcome to this Javascript Guide!” 应该输出为 “emocleW ot siht tpircsavaJ !ediuG”。 1234567891011var string = \"Welcome to this Javascript Guide!\";// Output becomes !ediuG tpircsavaJ siht ot emocleWvar reverseEntireSentence = reverseBySeparator(string, \"\");// Output becomes emocleW ot siht tpircsavaJ !ediuGvar reverseEachWord = reverseBySeparator(reverseEntireSentence, \" \");function reverseBySeparator(string, separator) &#123; return string.split(separator).reverse().join(separator);&#125; 乱序同字母字符串 给定两个字符串，判断是否颠倒字母而成的字符串，譬如Mary与Army就是同字母而顺序颠倒： 12345678910111213141516var firstWord = \"Mary\";var secondWord = \"Army\";isAnagram(firstWord, secondWord); // truefunction isAnagram(first, second) &#123; // For case insensitivity, change both words to lowercase. var a = first.toLowerCase(); var b = second.toLowerCase(); // Sort the strings, and join the resulting array to a string. Compare the results a = a.split(\"\").sort().join(\"\"); b = b.split(\"\").sort().join(\"\"); return a === b;&#125; 会问字符串 判断某个字符串是否为回文字符串，譬如racecar与race car都是回文字符串： 12345678910isPalindrome(\"racecar\"); // trueisPalindrome(\"race Car\"); // truefunction isPalindrome(word) &#123; // Replace all non-letter chars with \"\" and change to lowercase var lettersOnly = word.toLowerCase().replace(/\\s/g, \"\"); // Compare the string with the reversed version of the string return lettersOnly === lettersOnly.split(\"\").reverse().join(\"\");&#125; 栈与队列 使用两个栈实现入队与出队 123456789101112131415161718192021var inputStack = []; // First stackvar outputStack = []; // Second stack// For enqueue, just push the item into the first stackfunction enqueue(stackInput, item) &#123; return stackInput.push(item);&#125;function dequeue(stackInput, stackOutput) &#123; // Reverse the stack such that the first element of the output stack is the // last element of the input stack. After that, pop the top of the output to // get the first element that was ever pushed into the input stack if (stackOutput.length &lt;= 0) &#123; while(stackInput.length &gt; 0) &#123; var elementToOutput = stackInput.pop(); stackOutput.push(elementToOutput); &#125; &#125; return stackOutput.pop();&#125; 判断大括号是否闭合 创建一个函数来判断给定的表达式中的大括号是否闭合： 12345678910111213141516171819202122232425262728293031var expression = \"&#123;&#123;&#125;&#125;&#123;&#125;&#123;&#125;\"var expressionFalse = \"&#123;&#125;&#123;&#123;&#125;\";isBalanced(expression); // trueisBalanced(expressionFalse); // falseisBalanced(\"\"); // truefunction isBalanced(expression) &#123; var checkString = expression; var stack = []; // If empty, parentheses are technically balanced if (checkString.length &lt;= 0) return true; for (var i = 0; i &lt; checkString.length; i++) &#123; if(checkString[i] === '&#123;') &#123; stack.push(checkString[i]); &#125; else if (checkString[i] === '&#125;') &#123; // Pop on an empty array is undefined if (stack.length &gt; 0) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; &#125; // If the array is not empty, it is not balanced if (stack.pop()) return false; return true;&#125; 递归 二进制转换 通过某个递归函数将输入的数字转化为二进制字符串： 12345678910111213141516171819decimalToBinary(3); // 11decimalToBinary(8); // 1000decimalToBinary(1000); // 1111101000function decimalToBinary(digit) &#123; if(digit &gt;= 1) &#123; // If digit is not divisible by 2 then recursively return proceeding // binary of the digit minus 1, 1 is added for the leftover 1 digit if (digit % 2) &#123; return decimalToBinary((digit - 1) / 2) + 1; &#125; else &#123; // Recursively return proceeding binary digits return decimalToBinary(digit / 2) + 0; &#125; &#125; else &#123; // Exit condition return ''; &#125;&#125; 二分搜索12345678910111213function recursiveBinarySearch(array, value, leftPosition, rightPosition) &#123; // Value DNE if (leftPosition &gt; rightPosition) return -1; var middlePivot = Math.floor((leftPosition + rightPosition) / 2); if (array[middlePivot] === value) &#123; return middlePivot; &#125; else if (array[middlePivot] &gt; value) &#123; return recursiveBinarySearch(array, value, leftPosition, middlePivot - 1); &#125; else &#123; return recursiveBinarySearch(array, value, middlePivot + 1, rightPosition); &#125;&#125; 数字 判断是否为 2 的指数值 123456789101112131415161718192021222324isPowerOfTwo(4); // trueisPowerOfTwo(64); // trueisPowerOfTwo(1); // trueisPowerOfTwo(0); // falseisPowerOfTwo(-1); // false// For the non-zero case:function isPowerOfTwo(number) &#123; // `&amp;` uses the bitwise n. // In the case of number = 4; the expression would be identical to: // `return (4 &amp; 3 === 0)` // In bitwise, 4 is 100, and 3 is 011. Using &amp;, if two values at the same // spot is 1, then result is 1, else 0. In this case, it would return 000, // and thus, 4 satisfies are expression. // In turn, if the expression is `return (5 &amp; 4 === 0)`, it would be false // since it returns 101 &amp; 100 = 100 (NOT === 0) return number &amp; (number - 1) === 0;&#125;// For zero-case:function isPowerOfTwoZeroCase(number) &#123; return (number !== 0) &amp;&amp; ((number &amp; (number - 1)) === 0);&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://huayan.site/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://huayan.site/tags/算法/"}]},{"title":"浅谈模块化加载的实现原理","slug":"浅谈模块化加载的实现原理","date":"2017-05-10T08:51:22.000Z","updated":"2017-05-17T13:48:32.000Z","comments":true,"path":"2017/05/10/浅谈模块化加载的实现原理/","link":"","permalink":"http://huayan.site/2017/05/10/浅谈模块化加载的实现原理/","excerpt":"","text":"转载来自: 前端开发博客 浅谈模块化加载的实现原理相信很多人都用过 seajs、 requirejs 等这些模块加载器，他们都是十分便捷的工程管理工具，简化了代码的结构，更重要的是消除了各种文件依赖和命名冲突问题，并利用 AMD / CMD 规范统一了格式。如果你不太明白模块化的作用，建议看看玉伯写的一篇文章。 一是按需加载，业务越来越大，基础代码也会越来越多，开发人员可能开发了一百个小工具，而且都塞在一个叫做 utils.js 的包里，但是一个页面可能只需要三到五个小工具，如果直接去加载这个 utils.js 岂不是很大的浪费，PC 端还好，主要是无线端，省下 1KB 那都是很大的价值啊，所以呢，如今很多框架的开发都体现出细颗粒度的分化，像百度研究比较卖力的 tangram，阿里放满产品线的 kissy，几乎是细分到了微粒程度，这种细分方式也促进了模块化加载技术的发展，比如为了减少请求数量，kissy 的 config 中开启 combo 就可以合并多个请求为一个等等。 第二点，应该也是从服务器那边参考而来的，服务器脚本很多都是以文件为单位分离的，如果要利用其它文件的功能，可以轻而易举的 require 或者 include 进来，我没有去研究这些加载函数的内部实现原理，稍微猜猜应该是把文件写入到缓存，遇到 include 之类的加载函数，暂停写入，找到需要 include 的文件地址，把找到的文件接着上面继续写入缓存，以此类推，直到结束，然后编译器进行统一编译。 一、模块化加载的技术原理先不考虑各种模块定义规范，本文目的只是简要的分析加载原理， CMD / AMD 规范虽内容然不多，但是要实现起来，工程量还是不小。文章后面会提到。 1. 数据模块的加载既然是模块化加载，想办法把模块内容拿到当然是重头戏，无论是 script 还是 css 文件的加载，一个 script 或者 link 标签就可以搞定问题，不过我这里采用的是 ajax，目的是为了拿到 script 的代码，也是为了照顾后面要说的 CMD 规范。 1234567891011var require = function(path)&#123; var xhr = new XMLHttpRequest(), res; xhr.open(\"GET\", path, true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; // 获取源码 res = xhr.responseText; &#125; &#125; xhr.send();&#125;; 创建 script 标签加载脚本不会存在跨域问题，不过拿到的脚本会被浏览器立马解析出来，如果要做同异步的处理就比较麻烦了。没有跨域的文件我们就通过上面的方式加载，如果脚本跨域了，再去创建标签，让文档自己去加载。 1234567// 跨域处理if(crossDomain)&#123; var script = document.createElement(\"script\"); script.src = path; (document.getElementsByTagName(\"head\")[0] || document.body).appendChild(script);&#125; 2. 解析模块的层次依赖关系模块之间存在依赖关系是十分正常的，如一个工程的文件结构如下：12345678910project/├── css/│ └── main.css├── js/│ ├── require.js│ └── modlues/│ ├── a.js│ ├── b.js│ └── c.js└── index.html 而这里几个模块的依赖关系是： 123456789101112 ┌&gt; a.js -&gt; b.jsindex.html -| └&gt; c.js// a.jsrequire(\"./js/test/b.js\");// b.jsconsole.log(\"i am b\");// c.jsconsole.log(\"i am c\"); 我们要从 index.html 中利用 require.js 获取这一连串的依赖关系，一般采用的方式就是正则匹配。如下：先拿到 function 的代码，然后正则匹配出第一层的依赖关系，接着加载匹配到关系的代码，继续匹配。 1234567891011// index.html&lt;script type=\"text/javascript\" src=\"./js/require.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; function test()&#123; var a = require(\"./js/modlues/a.js\"); var c = require(\"./js/modlues/c.js\"); &#125; // toString 方法可以拿到 test 函数的 code start(test.toString());&lt;/script&gt; 整个函数的入口是 start，正则表达式为：1234567var r = /require\\((.*)\\)/g;var start = function(str)&#123; while(match = r.exec(str)) &#123; console.log(match[1]); &#125;&#125;; 由此我们拿到了第一层的依赖关系，1[\"./js/modlues/a.js\", \"./js/modlues/c.js\"] 接着要拿到 a.js 和 b.js 的文件层次依赖，之前我们写了一个 require 函数，这个函数可以拿到脚本的代码内容，不过这个 require 函数要稍微修改下，递归去查询和下载代码。 1234567891011121314151617181920212223var cache = &#123;&#125;;var start = function(str)&#123; while(match = r.exec(str)) &#123; console.log(match &amp;&amp; match[1]); // 如果匹配到了内容，下载 path 对应的源码 match &amp;&amp; match[1] &amp;&amp; require(match[1]); &#125;&#125;;var require = function(path)&#123; var xhr = new XMLHttpRequest(), res; xhr.open(\"GET\", path, true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; res = xhr.responseText; // 缓存文件 cache[path] = res; // 继续递归匹配 start(res); &#125; &#125; xhr.send();&#125;; 上面的代码已经可以很好地拿到文件递归关系了: 3. 添加事件机制，优化管理代码但是我们有必要先把 responseText 缓存起来，如果不缓存文件，直接 eval 得到的 responseText 代码，想想会发生什么问题~ 如果模块之间存在循环引用，如： 123 ┌&gt; a.js -&gt; b.jsindex.html -| └&gt; b.js -&gt; a.js 那 start 和 require 将会陷入死循环，不断的加载代码。所以我们需要先拿到依赖关系，然后解构关系，分析出我们需要加载哪些模块。值得注意的是，我们必须按照加载的顺序去 eval 代码，如果 a 依赖 b，先去执行 a 的话，一定会报错！ 有两个问题我纠结了半天，上面的请求方式，何时会结束？用什么方式去记录文件依赖关系？ 最后还是决定将 start 和 require 两个函数的相互递归修改成一个函数的递归。用一个对象，发起请求时把 URL 作为 key，在这个对象里保存 XHR 对象，XHR 对象请求完成后，把抓取到的新请求再用同样的方式放入这个对象中，同时从这个对象中把自己删除掉，然后判断这个对象上是否存在 key， 如果存在说明还有 XHR 对象没完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var r = /require\\(\\s*\"(.*)\"\\s*\\)/g;var cache = &#123;&#125;; // 文件缓存var relation = []; // 依赖过程控制var obj = &#123;&#125;; // xhr 管理对象//辅助函数，获取键值数组Object.keys = Object.keys || function(obj)&#123; var a = []; for(a[a.length] in obj); return a ;&#125;;// 入口函数function start(str)&#123; while(match = r.exec(str))&#123; obj[match[1]] = new XMLHttpRequest(); require(obj[match[1]], match[1]); &#125;&#125;// 递归请求var require = function(xhr, path)&#123; //记录依赖过程 relation.push(path); xhr.open(\"GET\", path, true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; var res = xhr.responseText; // 缓存文件 cache[path] = res; // 从xhr对象管理器中删除已经加载完毕的函数 delete obj[path]; // 如果obj为空则触发 allLoad 事件 Object.keys(obj).length == 0 ? Event.trigger(\"allLoad\") : void 0; //递归条件 while(match = r.exec(res))&#123; obj[match[1]] = new XMLHttpRequest(); require(obj[match[1]], match[1]); &#125; &#125; &#125; xhr.send();&#125;; 上面的代码已经基本完成了文件依赖分析，文件的加载和缓存工作了 CMD 规范的介绍 上面写了一大堆内容，也实现了模块加载器的原型，但是放在实际应用中，他就是个废品，回到最开始，我们为什么要使用模块化加载。目的是为了不去使用麻烦的命名空间，把复杂的模块依赖交给 require 这个函数去管理，但实际上呢，上面拿到的所有模块都是暴露在全局变量中的，也就是说，如果 a.js 和 b.js 中存在命名相同的变量，后者将会覆盖前者，这是我们不愿意看到的。为了处理此类问题，我们有必要把所有的模块都放到一个闭包中，这样一来，只要不使用 window.vars 命名，闭包之间的变量是不会相互影响的。我们可以使用自己的方式去管理代码，不过有人已经研究处理一套标准，而且是全球统一，那就拿着用吧~ 关于 CMD 规范，我这里就不多说了，可以去看看草案，玉伯也翻译了一份，戳我。每一模块有且仅有一个对外公开的接口 exports，如：123456789define(function(require, exports) &#123; // 对外提供 foo 属性 exports.foo = 'bar'; // 对外提供 doSomething 方法 exports.doSomething = function() &#123;&#125;;&#125;); 剩下的工作就是针对 CMD 规范写一套符合标准的代码接口，这个比较琐碎，就不写了。 二、额外的话题上面的代码中提到了关于 Event 的事件管理。在模块全部加在完毕之后，需要有个东西告诉你，所以顺手写了一个 Event 的事件管理器。12345678910111213141516171819202122232425262728293031// Eventvar Event = &#123;&#125;;Event.events = [];Event.on = function(evt, func)&#123; for(var i = 0; i &lt; Event.events.length; i++)&#123; if(Event.events[i].evt == evt)&#123; Event.events[i].func.push(func); return; &#125; &#125; Event.events.push(&#123; evt: evt, func: [func] &#125;);&#125;;Event.trigger = function(evt)&#123; for(var i = 0; i &lt; Event.events.length; i++)&#123; if(Event.events[i].evt == evt)&#123; for(var j = 0; j &lt; Event.events[i].func.length; j++)&#123; Event.events[i].func[j](); &#125; return; &#125; &#125;&#125;;Event.off = function(evt)&#123; for(var i = 0; i &lt; Event.events.length; i++)&#123; Event.events.splice(i, 1); &#125; &#125;; 我觉得 seajs 是一个很不错的模块加载器，如果感兴趣，可以去看看他的源码实现，代码不长，只有一千多行。模块的加载它采用的是创建文本节点，让文档去加载模块，实时查看状态为 interactive 的 script 标签，如果处于交互状态就拿到他的代码，接着删除节点。当节点数目为 0 的时候，加载工作完成。 本文没有考虑 css 文件的加载问题，我们可以把它当做一个没有 require 关键词的 js 文件，或者把它匹配出来之后另作处理，因为他是不可能存在模块依赖关系的。 三、参考资料seajs","categories":[],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://huayan.site/tags/模块化/"},{"name":"AMD","slug":"AMD","permalink":"http://huayan.site/tags/AMD/"},{"name":"CMD","slug":"CMD","permalink":"http://huayan.site/tags/CMD/"},{"name":"requirejs","slug":"requirejs","permalink":"http://huayan.site/tags/requirejs/"}]}]}