{"meta":{"title":"watson yan","subtitle":null,"description":null,"author":"watson yan","url":"http://huayan.site"},"pages":[{"title":"categories","date":"2017-05-15T07:59:13.000Z","updated":"2017-05-15T07:59:13.000Z","comments":true,"path":"categories/index.html","permalink":"http://huayan.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-15T08:08:12.000Z","updated":"2017-05-15T08:08:12.000Z","comments":false,"path":"tags/index.html","permalink":"http://huayan.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"神秘的属性描述符","slug":"神秘的属性描述符","date":"2017-06-16T01:59:52.000Z","updated":"2017-06-16T02:38:45.000Z","comments":true,"path":"2017/06/16/神秘的属性描述符/","link":"","permalink":"http://huayan.site/2017/06/16/神秘的属性描述符/","excerpt":"","text":"前面的话对于操作系统中的文件，我们可以驾轻就熟将其设置为只读、隐藏、系统文件或普通文件。于对象来说，属性描述符提供类似的功能，用来描述对象的值、是否可配置、是否可修改以及是否可枚举。本文就来介绍对象中神秘的属性描述符 描述符类型 对象属性描述符的类型分为两种：数据属性和访问器属性 数据属性数据属性(data property)包含一个数据值的位置，在这个位置可以读取和写入值。数据属性有4个特性 Configurable(可配置性) 可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true Enumerable(可枚举性) 可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true Writable(可写性) 可写性决定是否可以修改属性的值，默认值为true Value(属性值) 属性值包含这个属性的数据值，读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为undefined 访问器属性对象属性是名字、值和一组属性描述符构成的。而属性值可以用一个或两个方法替代，这两个方法就是getter和setter。而这种属性类型叫访问器属性(accessor property) Configurable(可配置性) 可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true Enumerable(可枚举性) 可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true getter 在读取属性时调用的函数。默认值为undefined setter 在写入属性时调用的函数。默认值为undefined 和数据属性不同，访问器属性不具有可写性(Writable)。如果属性同时具有getter和setter方法，那么它是一个读/写属性。如果它只有getter方法，那么它是一个只读属性。如果它只有setter方法，那么它是一个只写属性。读取只写属性总是返回undefined 描述符方法 前面介绍了属性描述符，要想设置它们，就需要用到描述符方法。描述符方法总共有以下4个： Object.getOwnPropertyDescriptor() Object.getOwnPropertyDescriptor(o,name)方法用于查询一个属性的描述符，并以对象的形式返回 查询obj.a属性时，可配置性、可枚举性、可写性都是默认的true，而value是a的属性值1 查询obj.b属性时，因为obj.b属性不存在，该方法返回undefined 12345var obj = &#123;a:1&#125;;//Object &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(obj,'a'));//undefinedconsole.log(Object.getOwnPropertyDescriptor(obj,'b')); Object.defineProperty() Object.defineProperty(o,name,desc)方法用于创建或配置对象的一个属性的描述符，返回配置后的对象 使用该方法创建或配置对象属性的描述符时，如果不针对该属性进行描述符的配置，则该项描述符默认为false 12345678910var obj = &#123;&#125;;//&#123;a:1&#125;console.log(Object.defineProperty(obj,'a',&#123; value:1, writable: true &#125;));//由于没有配置enumerable和configurable，所以它们的值为false//&#123;value: 1, writable: true, enumerable: false, configurable: false&#125;console.log(Object.getOwnPropertyDescriptor(obj,'a')); Object.defineProperties() Object.defineProperty(o,descriptors)方法用于创建或配置对象的多个属性的描述符，返回配置后的对象 12345678910111213var obj = &#123; a:1&#125;;//&#123;a: 1, b: 2&#125;console.log(Object.defineProperties(obj,&#123; a:&#123;writable:false&#125;, b:&#123;value:2&#125; &#125;));//&#123;value: 1, writable: false, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(obj,'a'));//&#123;value: 2, writable: false, enumerable: false, configurable: false&#125;console.log(Object.getOwnPropertyDescriptor(obj,'b')); Object.create() Object.create(proto,descriptors)方法使用指定的原型和属性来创建一个对象 12345var o = Object.create(Object.prototype,&#123; a:&#123;writable: false,value:1,enumerable:true&#125;&#125;);//&#123;value: 1, writable: false, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(obj,'a')); 描述符详述 前面分别介绍了数据属性和访问器属性的描述符，但没有详细说明其含义及使用，接下来逐一进行说明 可写性(writable)可写性决定是否可以修改属性的值，默认值为true1234var o = &#123;a:1&#125;;o.a = 2;console.log(o.a);//2 设置writable:false后，赋值语句会静默失效 1234567891011121314var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; writable:false&#125;);console.log(o.a);//1//由于设置了writable为false，所以o.a=2这个语句会静默失效o.a = 2;console.log(o.a);//1Object.defineProperty(o,'a',&#123; writable:true&#125;);//由于writable设置为true，所以o.a可以被修改为2o.a = 2;console.log(o.a);//2 在严格模式下通过赋值语句为writable为false的属性赋值，会提示类型错误TypeError 1234567'use strict';var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; writable:false&#125;);//Uncaught TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'o.a = 2; [注意]设置writable:false后，通过Object.defineProperty()方法改变属性value的值不会受影响，因为这也意味着在重置writable的属性值为false 123456789var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; writable:false&#125;);console.log(o.a);//1Object.defineProperty(o,'a',&#123; value:2&#125;);console.log(o.a);//2 可配置性(Configurable) 可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true 设置Configurable:false后，无法使用delete删除属性123456var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; configurable:false&#125;);delete o.a;//falseconsole.log(o.a);//1 在严格模式下删除为configurable为false的属性，会提示类型错误TypeError 1234567'use strict';var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; configurable:false&#125;);//Uncaught TypeError: Cannot delete property 'a' of #&lt;Object&gt;delete o.a; [注意]使用var命令声明变量时，变量的configurable为false 123var a = 1;//&#123;value: 1, writable: true, enumerable: true, configurable: false&#125;Object.getOwnPropertyDescriptor(this,'a'); 一般地，设置Configurable:false后，将无法再使用defineProperty()方法来修改属性描述符 12345678var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; configurable:false&#125;);//Uncaught TypeError: Cannot redefine property: aObject.defineProperty(o,'a',&#123; configurable:true&#125;); 有一个例外，设置Configurable:false后，只允许writable的状态从true变为false 12345678910111213var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123; configurable:false, writable:true&#125;);o.a = 2;console.log(o.a);//2Object.defineProperty(o,'a',&#123; writable:false&#125;);//由于writable:false生效，对象a的o属性无法修改值，所以o.a=3的赋值语句静默失败o.a = 3;console.log(o.a);//2 可枚举性(Enumerable) 可枚举性决定属性是否出现在对象的属性枚举中，具体来说，for-in循环、Object.keys方法、JSON.stringify方法是否会取到该属性 用户定义的普通属性默认是可枚举的，而原生继承的属性默认是不可枚举的12345//由于原生继承的属性默认不可枚举，所以只取得自定义的属性a:1var o = &#123;a:1&#125;;for(var i in o)&#123; console.log(o[i]);//1&#125; 123456//由于enumerable被设置为false，在for-in循环中a属性无法被枚举出来var o = &#123;a:1&#125;;Object.defineProperty(o,'a',&#123;enumerable:false&#125;);for(var i in o)&#123; console.log(o[i]);//undefined&#125; propertyIsEnumerable() propertyIsEnumerable()方法用于判断对象的属性是否可枚举1234var o = &#123;a:1&#125;;console.log(o.propertyIsEnumerable('a'));//trueObject.defineProperty(o,'a',&#123;enumerable:false&#125;);console.log(o.propertyIsEnumerable('a'));//false get和set get是一个隐藏函数，在获取属性值时调用。set也是一个隐藏函数，在设置属性值时调用，它们的默认值都是undefined。Object.definedProperty()中的get和set对应于对象字面量中get和set方法 [注意]getter和setter取代了数据属性中的value和writable属性 给只设置get方法，没有设置set方法的对象赋值会静默失败，在严格模式下会报错 123456789var o = &#123; get a()&#123; return 2; &#125;&#125; console.log(o.a);//2//由于没有设置set方法，所以o.a=3的赋值语句会静默失败o.a = 3;console.log(o.a);//2 123456789Object.defineProperty(o,'a',&#123; get: function()&#123; return 2; &#125;&#125;)console.log(o.a);//2//由于没有设置set方法，所以o.a=3的赋值语句会静默失败o.a = 3;console.log(o.a);//2 在严格模式下，给没有设置set方法的访问器属性赋值会报错 12345678910'use strict';var o = &#123; get a()&#123; return 2; &#125;&#125; console.log(o.a);//2//由于没有设置set方法，所以o.a=3的赋值语句会报错//Uncaught TypeError: Cannot set property a of #&lt;Object&gt; which has only a gettero.a = 3; 12345678910'use strict';Object.defineProperty(o,'a',&#123; get: function()&#123; return 2; &#125;&#125;)console.log(o.a);//2//由于没有设置set方法，所以o.a=3的赋值语句会报错//Uncaught TypeError: Cannot set property a of #&lt;Object&gt; which has only a gettero.a = 3; 只设置set方法，而不设置get方法，则对象属性值为undefined 1234567var o = &#123; set a(val)&#123; return 2; &#125;&#125; o.a = 1;console.log(o.a);//undefined 1234567Object.defineProperty(o,'a',&#123; set: function()&#123; return 2; &#125;&#125;)o.a = 1;console.log(o.a);//undefined 一般地，set和get方法是成对出现的 12345678910var o =&#123; get a()&#123; return this._a; &#125;, set a(val)&#123; this._a = val*2; &#125;&#125;o.a = 1;console.log(o.a);//2 12345678910Object.defineProperty(o,'a',&#123; get: function()&#123; return this._a; &#125;, set :function(val)&#123; this._a = val*2; &#125;&#125;)o.a = 1;console.log(o.a);//2 对象状态属性描述符只能用来控制对象中一个属性的状态。而如果要控制对象的状态，就要用到下面的6种方法 Object.preventExtensions()(禁止扩展) Object.preventExtensions()方法使一个对象无法再添加新的属性，并返回当前对象 Object.isExtensible()(测试扩展) Object.isExtensible()方法用来检测该对象是否可以扩展 123456789var o = &#123;a:1&#125;;console.log(Object.isExtensible(o));//trueo.b = 2;console.log(o);//&#123;a: 1, b: 2&#125;console.log(Object.preventExtensions(o));//&#123;a: 1, b: 2&#125;//由于对象o禁止扩展，所以该赋值语句静默失败o.c = 3;console.log(Object.isExtensible(o));//falseconsole.log(o);//&#123;a: 1, b: 2&#125; 在严格模式下，给禁止扩展的对象添加属性会报TypeError错误 12345'use strict';var o = &#123;a:1&#125;;console.log(Object.preventExtensions(o));//&#123;a:1&#125;//Uncaught TypeError: Can't add property c, object is not extensibleo.c = 3; Object.preventExtensions()方法并不改变对象中属性的描述符状态 123456var o = &#123;a:1&#125;;//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(o,'a'));Object.preventExtensions(o);//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(o,'a')); Object.seal()(对象封印) 对象封印又叫对象密封，使一个对象不可扩展并且所有属性不可配置，并返回当前对象 Object.isSealed()(测试封印) Object.isSealed()方法用来检测该方法是否被封印 1234567var o = &#123;a:1,b:2&#125;;console.log(Object.isSealed(o));//falseconsole.log(Object.seal(o));//&#123;a:1,b:2&#125;console.log(Object.isSealed(o));//trueconsole.log(delete o.b);//falseo.c = 3;console.log(o);//&#123;a:1,b:2&#125; 在严格模式下，删除旧属性或添加新属性都会报错 12345'use strict';var o = &#123;a:1,b:2&#125;;console.log(Object.seal(o));//&#123;a:1,b:2&#125;//Uncaught TypeError: Cannot delete property 'b' of #&lt;Object&gt;delete o.b; 这个方法实际上会在现有对象上调用Object.preventExtensions()方法，并把所有现有属性的configurable描述符置为false 123456var o = &#123;a:1,b:2&#125;;//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(o,'a'));console.log(Object.seal(o));//&#123;a:1,b:2&#125;//&#123;value: 1, writable: true, enumerable: true, configurable: false&#125;console.log(Object.getOwnPropertyDescriptor(o,'a')); Object.freeze()(对象冻结) Object.freeze()方法使一个对象不可扩展，不可配置，也不可改写，变成一个仅可以枚举的只读常量，并返回当前对象 Object.isFrozen()(检测冻结) Object.isFrozen()方法用来检测一个对象是否被冻结 123456var o = &#123;a:1,b:2&#125;;console.log(Object.isFrozen(o));//falseconsole.log(Object.freeze(o));//&#123;a:1,b:2&#125;console.log(Object.isFrozen(o));//trueo.a = 3;console.log(o);//&#123;a:1,b:2&#125; 在严格模式下，删除旧属性、添加新属性、更改现有属性都会报错 12345'use strict';var o = &#123;a:1,b:2&#125;;console.log(Object.freeze(o));//&#123;a:1,b:2&#125;//Uncaught TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'o.a = 3; 这个方法实际上会在现有对象上调用Object.seal()方法，并把所有现有属性的writable描述符置为false 123456var o = &#123;a:1&#125;;//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(o,'a'));console.log(Object.freeze(o));//&#123;a:1&#125;//&#123;value: 1, writable: false, enumerable: true, configurable: false&#125;console.log(Object.getOwnPropertyDescriptor(o,'a'));","categories":[],"tags":[{"name":"双向绑定","slug":"双向绑定","permalink":"http://huayan.site/tags/双向绑定/"},{"name":"属性访问器","slug":"属性访问器","permalink":"http://huayan.site/tags/属性访问器/"}]},{"title":"Javascript角度理解发布订阅者模式","slug":"Javascript角度理解发布订阅者模式","date":"2017-06-14T08:51:22.000Z","updated":"2017-06-15T03:37:42.000Z","comments":true,"path":"2017/06/14/Javascript角度理解发布订阅者模式/","link":"","permalink":"http://huayan.site/2017/06/14/Javascript角度理解发布订阅者模式/","excerpt":"","text":"原文地址 发布订阅模式介绍 发布订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 现实生活中的发布-订阅模式；比如小红最近在淘宝网上看上一双鞋子，但是呢 联系到卖家后，才发现这双鞋卖光了，但是小红对这双鞋又非常喜欢，所以呢联系卖家，问卖家什么时候有货，卖家告诉她，要等一个星期后才有货，卖家告诉小红，要是你喜欢的话，你可以收藏我们的店铺，等有货的时候再通知你，所以小红收藏了此店铺，但与此同时，小明，小花等也喜欢这双鞋，也收藏了该店铺；等来货的时候就依次会通知他们； 在上面的故事中，可以看出是一个典型的发布订阅模式，卖家是属于发布者，小红，小明等属于订阅者，订阅该店铺，卖家作为发布者，当鞋子到了的时候，会依次通知小明，小红等，依次使用旺旺等工具给他们发布消息； 发布订阅模式的优点： 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。比如上面的列子，小明，小红不需要天天逛淘宝网看鞋子到了没有，在合适的时间点，发布者(卖家)来货了的时候，会通知该订阅者(小红，小明等人)。 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变；同理卖家（发布者）它只需要将鞋子来货的这件事告诉订阅者(买家)，他不管买家到底买还是不买，还是买其他卖家的。只要鞋子到货了就通知订阅者即可。 对于第一点，我们日常工作中也经常使用到，比如我们的ajax请求，请求有成功(success)和失败(error)的回调函数，我们可以订阅ajax的success和error事件。我们并不关心对象在异步运行的状态，我们只关心success的时候或者error的时候我们要做点我们自己的事情就可以了~ 发布订阅模式的缺点： 创建订阅者需要消耗一定的时间和内存。 虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等 如何实现发布–订阅模式？ 首先要想好谁是发布者(比如上面的卖家)。 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。 最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 我们还可以在回调函数里面添加一点参数，比如鞋子的颜色，鞋子尺码等信息； 我们先来实现下简单的发布-订阅模式；代码如下：123456789101112131415161718192021222324252627var shoeObj = &#123;&#125;; // 定义发布者shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者shoeObj.listen = function(fn) &#123; shoeObj.list.push(fn); // 订阅消息添加到缓存列表&#125;// 发布消息shoeObj.trigger = function()&#123; for(var i = 0,fn; fn = this.list[i++];) &#123; fn.apply(this,arguments); &#125;&#125;// 小红订阅如下消息shoeObj.listen(function(color,size)&#123; console.log(\"颜色是：\"+color); console.log(\"尺码是：\"+size); &#125;);// 小花订阅如下消息shoeObj.listen(function(color,size)&#123; console.log(\"再次打印颜色是：\"+color); console.log(\"再次打印尺码是：\"+size); &#125;);shoeObj.trigger(\"红色\",40);shoeObj.trigger(\"黑色\",42); 打印如上截图，我们看到订阅者接收到发布者的每个消息，但是呢，对于小红来说，她只想接收颜色为红色的消息，不想接收颜色为黑色的消息，为此我们需要对代码进行如下改造下，我们可以先增加一个key，使订阅者只订阅自己感兴趣的消息。 12345678910111213141516171819202122232425262728293031323334353637var shoeObj = &#123;&#125;; // 定义发布者shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者shoeObj.listen = function(key,fn) &#123; if(!this.list[key]) &#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表 this.list[key] = []; &#125; this.list[key].push(fn); // 订阅消息添加到缓存列表&#125;// 发布消息shoeObj.trigger = function()&#123; var key = Array.prototype.shift.call(arguments); // 取出消息类型名称 var fns = this.list[key]; // 取出该消息对应的回调函数的集合 // 如果没有订阅过该消息的话，则返回 if(!fns || fns.length === 0) &#123; return; &#125; for(var i = 0,fn; fn = fns[i++]; ) &#123; fn.apply(this,arguments); // arguments 是发布消息时附送的参数 &#125;&#125;;// 小红订阅如下消息shoeObj.listen('red',function(size)&#123; console.log(\"尺码是：\"+size); &#125;);// 小花订阅如下消息shoeObj.listen('block',function(size)&#123; console.log(\"再次打印尺码是：\"+size); &#125;);shoeObj.trigger(\"red\",40);shoeObj.trigger(\"block\",42); 上面的代码，我们再来运行打印下 如下：可以看到，订阅者只订阅自己感兴趣的消息了； 发布—订阅模式的代码封装我们知道，对于上面的代码，小红去买鞋这么一个对象shoeObj 进行订阅，但是如果以后我们需要对买房子或者其他的对象进行订阅呢，我们需要复制上面的代码，再重新改下里面的对象代码；为此我们需要进行代码封装； 如下代码封装：123456789101112131415161718192021var event = &#123; list: [], listen: function(key,fn) &#123; if(!this.list[key]) &#123; this.list[key] = []; &#125; // 订阅的消息添加到缓存列表中 this.list[key].push(fn); &#125;, trigger: function()&#123; var key = Array.prototype.shift.call(arguments); var fns = this.list[key]; // 如果没有订阅过该消息的话，则返回 if(!fns || fns.length === 0) &#123; return; &#125; for(var i = 0,fn; fn = fns[i++];) &#123; fn.apply(this,arguments); &#125; &#125;&#125;; 我们在定义一个initEvent函数，这个函数使所有的普通对象都具有发布订阅功能，如下代码： 123456789101112131415161718192021var initEvent = function(obj) &#123; for(var i in event) &#123; obj[i] = event[i]; &#125;&#125;;// 我们再来测试下，我们还是给shoeObj这个对象添加发布-订阅功能；var shoeObj = &#123;&#125;;initEvent(shoeObj);// 小红订阅如下消息shoeObj.listen('red',function(size)&#123; console.log(\"尺码是：\"+size); &#125;);// 小花订阅如下消息shoeObj.listen('block',function(size)&#123; console.log(\"再次打印尺码是：\"+size); &#125;);shoeObj.trigger(\"red\",40);shoeObj.trigger(\"block\",42); 如何取消订阅事件？比如上面的列子，小红她突然不想买鞋子了，那么对于卖家的店铺他不想再接受该店铺的消息，那么小红可以取消该店铺的订阅。 如下代码：123456789101112131415161718event.remove = function(key,fn)&#123; var fns = this.list[key]; // 如果key对应的消息没有订阅过的话，则返回 if(!fns) &#123; return false; &#125; // 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅 if(!fn) &#123; fn &amp;&amp; (fns.length = 0); &#125;else &#123; for(var i = fns.length - 1; i &gt;= 0; i--) &#123; var _fn = fns[i]; if(_fn === fn) &#123; fns.splice(i,1); // 删除订阅者的回调函数 &#125; &#125; &#125;&#125;; 测试代码如下：12345678910111213141516171819var initEvent = function(obj) &#123; for(var i in event) &#123; obj[i] = event[i]; &#125;&#125;;var shoeObj = &#123;&#125;;initEvent(shoeObj);// 小红订阅如下消息shoeObj.listen('red',fn1 = function(size)&#123; console.log(\"尺码是：\"+size); &#125;);// 小花订阅如下消息shoeObj.listen('red',fn2 = function(size)&#123; console.log(\"再次打印尺码是：\"+size); &#125;);shoeObj.remove(\"red\",fn1);shoeObj.trigger(\"red\",42); 运行结果如下： 全局–发布订阅对象代码封装我们再来看看我们传统的ajax请求吧，比如我们传统的ajax请求，请求成功后需要做如下事情： 渲染数据。 使用数据来做一个动画。 那么我们以前肯定是如下写代码：1234$.ajax(“http://127.0.0.1/index.php”,function(data)&#123; rendedData(data); // 渲染数据 doAnimate(data); // 实现动画 &#125;); 假如以后还需要做点事情的话，我们还需要在里面写调用的方法；这样代码就耦合性很高，那么我们现在使用发布-订阅模式来看如何重构上面的业务需求代码； 1234567891011$.ajax(“http://127.0.0.1/index.php”,function(data)&#123; Obj.trigger(‘success’,data); // 发布请求成功后的消息&#125;);// 下面我们来订阅此消息，比如我现在订阅渲染数据这个消息；Obj.listen(“success”,function(data)&#123; renderData(data);&#125;);// 订阅动画这个消息Obj.listen(“success”,function(data)&#123; doAnimate(data); &#125;); 为此我们可以封装一个全局发布-订阅模式对象；如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var Event = (function()&#123; var list = &#123;&#125;, listen, trigger, remove; listen = function(key,fn)&#123; if(!list[key]) &#123; list[key] = []; &#125; list[key].push(fn); &#125;; trigger = function()&#123; var key = Array.prototype.shift.call(arguments), fns = list[key]; if(!fns || fns.length === 0) &#123; return false; &#125; for(var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this,arguments); &#125; &#125;; remove = function(key,fn)&#123; var fns = list[key]; if(!fns) &#123; return false; &#125; if(!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125;else &#123; for(var i = fns.length - 1; i &gt;= 0; i--)&#123; var _fn = fns[i]; if(_fn === fn) &#123; fns.splice(i,1); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;&#125;)();// 测试代码如下：Event.listen(\"color\",function(size) &#123; console.log(\"尺码为:\"+size); // 打印出尺码为42&#125;);Event.trigger(\"color\",42); 理解模块间通信我们使用上面封装的全局的发布-订阅对象来实现两个模块之间的通信问题；比如现在有一个页面有一个按钮，每次点击此按钮后，div中会显示此按钮被点击的总次数；如下代码：12&lt;button id=\"count\"&gt;点将我&lt;/button&gt;&lt;div id=\"showcount\"&gt;&lt;/div&gt; 我们中的a.js 负责处理点击操作 及 发布消息；如下JS代码：1234567var a = (function()&#123; var count = 0; var button = document.getElementById(\"count\"); button.onclick = function()&#123; Event.trigger(\"add\",count++); &#125;&#125;)(); b.js 负责监听add这个消息，并把点击的总次数显示到页面上来；如下代码：123456var b = (function()&#123; var div = document.getElementById(\"showcount\"); Event.listen('add',function(count)&#123; div.innerHTML = count; &#125;);&#125;)(); 下面是html代码如下，JS应用如下引用即可：1234567891011121314&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"global.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"count\"&gt;点将我&lt;/button&gt; &lt;div id=\"showcount\"&gt;&lt;/div&gt; &lt;script src = \"a.js\"&gt;&lt;/script&gt; &lt;script src = \"b.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如上代码，当点击一次按钮后，showcount的div会自动加1，如上演示的是2个模块之间如何使用发布-订阅模式之间的通信问题； 其中global.js 就是我们上面封装的全局-发布订阅模式对象的封装代码；","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://huayan.site/tags/设计模式/"}]},{"title":"JavaScript深入之从原型到原型链","slug":"JavaScript深入之从原型到原型链","date":"2017-05-21T08:51:22.000Z","updated":"2017-06-03T16:12:41.000Z","comments":true,"path":"2017/05/21/JavaScript深入之从原型到原型链/","link":"","permalink":"http://huayan.site/2017/05/21/JavaScript深入之从原型到原型链/","excerpt":"","text":"JavaScript深入之从原型到原型链原文出处： 冴羽 JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。 构造函数创建对象我们先使用构造函数创建一个对象： 123456function Person() &#123;&#125;var person = new Person();person.name = 'Kevin';console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： 12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = 'Kevin';var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 构造函数和实例原型的关系图 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： __proto__这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 实例与实例原型的关系图 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor ，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 实例原型与构造函数的关系图 综上我们已经得出： 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 12345678910111213function Person() &#123;&#125;Person.prototype.name = 'Kevin';var person = new Person();person.name = 'Daisy';console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = 'Kevin'console.log(obj.name) // Kevin 所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型的原型关系图 原型链那 Object.prototype 的原型呢？ null，不信我们可以打印： 1console.log(Object.prototype.__proto__ === null) // true 所以查到属性的时候查到 Object.prototype 就可以停止查找了。 所以最后一张关系图就是 原型链示意图 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor首先是 constructor 属性，我们看个例子： 12345function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： 1person.constructor === Person.prototype.constructor __proto__其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 下一篇文章JavaScript深入之词法作用域和动态作用域 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[{"name":"原型","slug":"原型","permalink":"http://huayan.site/tags/原型/"},{"name":"原型链","slug":"原型链","permalink":"http://huayan.site/tags/原型链/"},{"name":"prototype","slug":"prototype","permalink":"http://huayan.site/tags/prototype/"}]},{"title":"JavaScript 面试中常见算法问题详解","slug":"JavaScript-面试中常见算法问题详解","date":"2017-05-15T08:51:22.000Z","updated":"2017-05-17T13:28:43.000Z","comments":true,"path":"2017/05/15/JavaScript-面试中常见算法问题详解/","link":"","permalink":"http://huayan.site/2017/05/15/JavaScript-面试中常见算法问题详解/","excerpt":"","text":"原文出处：王下邀月熊_Chevalier JavaScript Specification阐述下 JavaScript 中的变量提升所谓提升，顾名思义即是 JavaScript 会将所有的声明提升到当前作用域的顶部。这也就意味着我们可以在某个变量声明前就使用该变量，不过虽然 JavaScript 会将声明提升到顶部，但是并不会执行真的初始化过程。 阐述下 use strict; 的作用use strict; 顾名思义也就是 JavaScript 会在所谓严格模式下执行，其一个主要的优势在于能够强制开发者避免使用未声明的变量。对于老版本的浏览器或者执行引擎则会自动忽略该指令。 12345678// Example of strict mode\"use strict\";catchThemAll();function catchThemAll() &#123; x = 3.14; // Error will be thrown return x * x;&#125; 解释下什么是 Event Bubbling 以及如何避免Event Bubbling 即指某个事件不仅会触发当前元素，还会以嵌套顺序传递到父元素中。直观而言就是对于某个子元素的点击事件同样会被父元素的点击事件处理器捕获。避免 Event Bubbling 的方式可以使用event.stopPropagation() 或者 IE 9 以下使用event.cancelBubble。 == 与 === 的区别是什么=== 也就是所谓的严格比较，关键的区别在于=== 会同时比较类型与值，而不是仅比较值。123456// Example of comparators0 == false; // true0 === false; // false2 == &apos;2&apos;; // true2 === &apos;2&apos;; // false 解释下 null 与 undefined 的区别JavaScript 中，null 是一个可以被分配的值，设置为 null 的变量意味着其无值。而 undefined 则代表着某个变量虽然声明了但是尚未进行过任何赋值。 解释下 Prototypal Inheritance 与 Classical Inheritance 的区别在类继承中，类是不可变的，不同的语言中对于多继承的支持也不一样，有些语言中还支持接口、final、abstract 的概念。而原型继承则更为灵活，原型本身是可以可变的，并且对象可能继承自多个原型。 数组找出整型数组中乘积最大的三个数给定一个包含整数的无序数组，要求找出乘积最大的三个数。 12345678910111213141516171819202122232425var unsorted_array = [-10, 7, 29, 30, 5, -10, -70];computeProduct(unsorted_array); // 21000function sortIntegers(a, b) &#123; return a - b;&#125;// greatest product is either (min1 * min2 * max1 || max1 * max2 * max3)function computeProduct(unsorted) &#123; var sorted_array = unsorted.sort(sortIntegers), product1 = 1, product2 = 1, array_n_element = sorted_array.length - 1; // Get the product of three largest integers in sorted array for (var x = array_n_element; x &gt; array_n_element - 3; x--) &#123; product1 = product1 * sorted_array[x]; &#125; product2 = sorted_array[0] * sorted_array[1] * sorted_array[array_n_element]; if (product1 &gt; product2) return product1; return product2&#125;; 寻找连续数组中的缺失数 给定某无序数组，其包含了 n 个连续数字中的 n - 1 个，已知上下边界，要求以O(n)的复杂度找出缺失的数字。 123456789101112131415161718192021222324252627// The output of the function should be 8var array_of_integers = [2, 5, 1, 4, 9, 6, 3, 7];var upper_bound = 9;var lower_bound = 1;findMissingNumber(array_of_integers, upper_bound, lower_bound); //8function findMissingNumber(array_of_integers, upper_bound, lower_bound) &#123; // Iterate through array to find the sum of the numbers var sum_of_integers = 0; for (var i = 0; i &lt; array_of_integers.length; i++) &#123; sum_of_integers += array_of_integers[i]; &#125; // 以高斯求和公式计算理论上的数组和 // Formula: [(N * (N + 1)) / 2] - [(M * (M - 1)) / 2]; // N is the upper bound and M is the lower bound upper_limit_sum = (upper_bound * (upper_bound + 1)) / 2; lower_limit_sum = (lower_bound * (lower_bound - 1)) / 2; theoretical_sum = upper_limit_sum - lower_limit_sum; // return (theoretical_sum - sum_of_integers)&#125; 数组去重 给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。1234567891011121314151617181920212223// ES6 Implementationvar array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]// ES5 Implementationvar array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];uniqueArray(array); // [1, 2, 3, 5, 9, 8]function uniqueArray(array) &#123; var hashmap = &#123;&#125;; var unique = []; for(var i = 0; i &lt; array.length; i++) &#123; // If key returns null (unique), it is evaluated as false. if(!hashmap.hasOwnProperty([array[i]])) &#123; hashmap[array[i]] = 1; unique.push(array[i]); &#125; &#125; return unique;&#125; 数组中元素最大差值计算 给定某无序数组，求取任意两个元素之间的最大差值，注意，这里要求差值计算中较小的元素下标必须小于较大元素的下标。譬如[7, 8, 4, 9, 9, 15, 3, 1, 10]这个数组的计算值是 11( 15 - 4 ) 而不是 14(15 - 1)，因为 15 的下标小于 1。 123456789101112131415161718192021222324252627282930313233var array = [7, 8, 4, 9, 9, 15, 3, 1, 10];// [7, 8, 4, 9, 9, 15, 3, 1, 10] would return `11` based on the difference between `4` and `15`// Notice: It is not `14` from the difference between `15` and `1` because 15 comes before 1.findLargestDifference(array);function findLargestDifference(array) &#123; // 如果数组仅有一个元素，则直接返回 -1 if (array.length &lt;= 1) return -1; // current_min 指向当前的最小值 var current_min = array[0]; var current_max_difference = 0; // 遍历整个数组以求取当前最大差值，如果发现某个最大差值，则将新的值覆盖 current_max_difference // 同时也会追踪当前数组中的最小值，从而保证 `largest value in future` - `smallest value before it` for (var i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; current_min &amp;&amp; (array[i] - current_min &gt; current_max_difference)) &#123; current_max_difference = array[i] - current_min; &#125; else if (array[i] &lt;= current_min) &#123; current_min = array[i]; &#125; &#125; // If negative or 0, there is no largest difference if (current_max_difference &lt;= 0) return -1; return current_max_difference;&#125; 数组中元素乘积 给定某无序数组，要求返回新数组 output ，其中 output[i] 为原数组中除了下标为 i 的元素之外的元素乘积，要求以 O(n) 复杂度实现： 1234567891011121314151617181920212223242526272829303132var firstArray = [2, 2, 4, 1];var secondArray = [0, 0, 0, 2];var thirdArray = [-2, -2, -3, 2];productExceptSelf(firstArray); // [8, 8, 4, 16]productExceptSelf(secondArray); // [0, 0, 0, 0]productExceptSelf(thirdArray); // [12, 12, 8, -12]function productExceptSelf(numArray) &#123; var product = 1; var size = numArray.length; var output = []; // From first array: [1, 2, 4, 16] // The last number in this case is already in the right spot (allows for us) // to just multiply by 1 in the next step. // This step essentially gets the product to the left of the index at index + 1 for (var x = 0; x &lt; size; x++) &#123; output.push(product); product = product * numArray[x]; &#125; // From the back, we multiply the current output element (which represents the product // on the left of the index, and multiplies it by the product on the right of the element) var product = 1; for (var i = size - 1; i &gt; -1; i--) &#123; output[i] = output[i] * product; product = product * numArray[i]; &#125; return output;&#125; 数组交集 给定两个数组，要求求出两个数组的交集，注意，交集中的元素应该是唯一的。 1234567891011121314151617181920212223242526272829var firstArray = [2, 2, 4, 1];var secondArray = [1, 2, 0, 2];intersection(firstArray, secondArray); // [2, 1]function intersection(firstArray, secondArray) &#123; // The logic here is to create a hashmap with the elements of the firstArray as the keys. // After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash // If it does exist, add that element to the new array. var hashmap = &#123;&#125;; var intersectionArray = []; firstArray.forEach(function(element) &#123; hashmap[element] = 1; &#125;); // Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added secondArray.forEach(function(element) &#123; if (hashmap[element] === 1) &#123; intersectionArray.push(element); hashmap[element]++; &#125; &#125;); return intersectionArray; // Time complexity O(n), Space complexity O(n)&#125; 字符串 颠倒字符串给定某个字符串，要求将其中单词倒转之后然后输出，譬如”Welcome to this Javascript Guide!” 应该输出为 “emocleW ot siht tpircsavaJ !ediuG”。 1234567891011var string = \"Welcome to this Javascript Guide!\";// Output becomes !ediuG tpircsavaJ siht ot emocleWvar reverseEntireSentence = reverseBySeparator(string, \"\");// Output becomes emocleW ot siht tpircsavaJ !ediuGvar reverseEachWord = reverseBySeparator(reverseEntireSentence, \" \");function reverseBySeparator(string, separator) &#123; return string.split(separator).reverse().join(separator);&#125; 乱序同字母字符串 给定两个字符串，判断是否颠倒字母而成的字符串，譬如Mary与Army就是同字母而顺序颠倒： 12345678910111213141516var firstWord = \"Mary\";var secondWord = \"Army\";isAnagram(firstWord, secondWord); // truefunction isAnagram(first, second) &#123; // For case insensitivity, change both words to lowercase. var a = first.toLowerCase(); var b = second.toLowerCase(); // Sort the strings, and join the resulting array to a string. Compare the results a = a.split(\"\").sort().join(\"\"); b = b.split(\"\").sort().join(\"\"); return a === b;&#125; 会问字符串 判断某个字符串是否为回文字符串，譬如racecar与race car都是回文字符串： 12345678910isPalindrome(\"racecar\"); // trueisPalindrome(\"race Car\"); // truefunction isPalindrome(word) &#123; // Replace all non-letter chars with \"\" and change to lowercase var lettersOnly = word.toLowerCase().replace(/\\s/g, \"\"); // Compare the string with the reversed version of the string return lettersOnly === lettersOnly.split(\"\").reverse().join(\"\");&#125; 栈与队列 使用两个栈实现入队与出队 123456789101112131415161718192021var inputStack = []; // First stackvar outputStack = []; // Second stack// For enqueue, just push the item into the first stackfunction enqueue(stackInput, item) &#123; return stackInput.push(item);&#125;function dequeue(stackInput, stackOutput) &#123; // Reverse the stack such that the first element of the output stack is the // last element of the input stack. After that, pop the top of the output to // get the first element that was ever pushed into the input stack if (stackOutput.length &lt;= 0) &#123; while(stackInput.length &gt; 0) &#123; var elementToOutput = stackInput.pop(); stackOutput.push(elementToOutput); &#125; &#125; return stackOutput.pop();&#125; 判断大括号是否闭合 创建一个函数来判断给定的表达式中的大括号是否闭合： 12345678910111213141516171819202122232425262728293031var expression = \"&#123;&#123;&#125;&#125;&#123;&#125;&#123;&#125;\"var expressionFalse = \"&#123;&#125;&#123;&#123;&#125;\";isBalanced(expression); // trueisBalanced(expressionFalse); // falseisBalanced(\"\"); // truefunction isBalanced(expression) &#123; var checkString = expression; var stack = []; // If empty, parentheses are technically balanced if (checkString.length &lt;= 0) return true; for (var i = 0; i &lt; checkString.length; i++) &#123; if(checkString[i] === '&#123;') &#123; stack.push(checkString[i]); &#125; else if (checkString[i] === '&#125;') &#123; // Pop on an empty array is undefined if (stack.length &gt; 0) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; &#125; // If the array is not empty, it is not balanced if (stack.pop()) return false; return true;&#125; 递归 二进制转换 通过某个递归函数将输入的数字转化为二进制字符串： 12345678910111213141516171819decimalToBinary(3); // 11decimalToBinary(8); // 1000decimalToBinary(1000); // 1111101000function decimalToBinary(digit) &#123; if(digit &gt;= 1) &#123; // If digit is not divisible by 2 then recursively return proceeding // binary of the digit minus 1, 1 is added for the leftover 1 digit if (digit % 2) &#123; return decimalToBinary((digit - 1) / 2) + 1; &#125; else &#123; // Recursively return proceeding binary digits return decimalToBinary(digit / 2) + 0; &#125; &#125; else &#123; // Exit condition return ''; &#125;&#125; 二分搜索12345678910111213function recursiveBinarySearch(array, value, leftPosition, rightPosition) &#123; // Value DNE if (leftPosition &gt; rightPosition) return -1; var middlePivot = Math.floor((leftPosition + rightPosition) / 2); if (array[middlePivot] === value) &#123; return middlePivot; &#125; else if (array[middlePivot] &gt; value) &#123; return recursiveBinarySearch(array, value, leftPosition, middlePivot - 1); &#125; else &#123; return recursiveBinarySearch(array, value, middlePivot + 1, rightPosition); &#125;&#125; 数字 判断是否为 2 的指数值 123456789101112131415161718192021222324isPowerOfTwo(4); // trueisPowerOfTwo(64); // trueisPowerOfTwo(1); // trueisPowerOfTwo(0); // falseisPowerOfTwo(-1); // false// For the non-zero case:function isPowerOfTwo(number) &#123; // `&amp;` uses the bitwise n. // In the case of number = 4; the expression would be identical to: // `return (4 &amp; 3 === 0)` // In bitwise, 4 is 100, and 3 is 011. Using &amp;, if two values at the same // spot is 1, then result is 1, else 0. In this case, it would return 000, // and thus, 4 satisfies are expression. // In turn, if the expression is `return (5 &amp; 4 === 0)`, it would be false // since it returns 101 &amp; 100 = 100 (NOT === 0) return number &amp; (number - 1) === 0;&#125;// For zero-case:function isPowerOfTwoZeroCase(number) &#123; return (number !== 0) &amp;&amp; ((number &amp; (number - 1)) === 0);&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://huayan.site/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://huayan.site/tags/算法/"}]},{"title":"浅谈模块化加载的实现原理","slug":"浅谈模块化加载的实现原理","date":"2017-05-10T08:51:22.000Z","updated":"2017-05-17T13:48:32.000Z","comments":true,"path":"2017/05/10/浅谈模块化加载的实现原理/","link":"","permalink":"http://huayan.site/2017/05/10/浅谈模块化加载的实现原理/","excerpt":"","text":"转载来自: 前端开发博客 浅谈模块化加载的实现原理相信很多人都用过 seajs、 requirejs 等这些模块加载器，他们都是十分便捷的工程管理工具，简化了代码的结构，更重要的是消除了各种文件依赖和命名冲突问题，并利用 AMD / CMD 规范统一了格式。如果你不太明白模块化的作用，建议看看玉伯写的一篇文章。 一是按需加载，业务越来越大，基础代码也会越来越多，开发人员可能开发了一百个小工具，而且都塞在一个叫做 utils.js 的包里，但是一个页面可能只需要三到五个小工具，如果直接去加载这个 utils.js 岂不是很大的浪费，PC 端还好，主要是无线端，省下 1KB 那都是很大的价值啊，所以呢，如今很多框架的开发都体现出细颗粒度的分化，像百度研究比较卖力的 tangram，阿里放满产品线的 kissy，几乎是细分到了微粒程度，这种细分方式也促进了模块化加载技术的发展，比如为了减少请求数量，kissy 的 config 中开启 combo 就可以合并多个请求为一个等等。 第二点，应该也是从服务器那边参考而来的，服务器脚本很多都是以文件为单位分离的，如果要利用其它文件的功能，可以轻而易举的 require 或者 include 进来，我没有去研究这些加载函数的内部实现原理，稍微猜猜应该是把文件写入到缓存，遇到 include 之类的加载函数，暂停写入，找到需要 include 的文件地址，把找到的文件接着上面继续写入缓存，以此类推，直到结束，然后编译器进行统一编译。 一、模块化加载的技术原理先不考虑各种模块定义规范，本文目的只是简要的分析加载原理， CMD / AMD 规范虽内容然不多，但是要实现起来，工程量还是不小。文章后面会提到。 1. 数据模块的加载既然是模块化加载，想办法把模块内容拿到当然是重头戏，无论是 script 还是 css 文件的加载，一个 script 或者 link 标签就可以搞定问题，不过我这里采用的是 ajax，目的是为了拿到 script 的代码，也是为了照顾后面要说的 CMD 规范。 1234567891011var require = function(path)&#123; var xhr = new XMLHttpRequest(), res; xhr.open(\"GET\", path, true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; // 获取源码 res = xhr.responseText; &#125; &#125; xhr.send();&#125;; 创建 script 标签加载脚本不会存在跨域问题，不过拿到的脚本会被浏览器立马解析出来，如果要做同异步的处理就比较麻烦了。没有跨域的文件我们就通过上面的方式加载，如果脚本跨域了，再去创建标签，让文档自己去加载。 1234567// 跨域处理if(crossDomain)&#123; var script = document.createElement(\"script\"); script.src = path; (document.getElementsByTagName(\"head\")[0] || document.body).appendChild(script);&#125; 2. 解析模块的层次依赖关系模块之间存在依赖关系是十分正常的，如一个工程的文件结构如下：12345678910project/├── css/│ └── main.css├── js/│ ├── require.js│ └── modlues/│ ├── a.js│ ├── b.js│ └── c.js└── index.html 而这里几个模块的依赖关系是： 123456789101112 ┌&gt; a.js -&gt; b.jsindex.html -| └&gt; c.js// a.jsrequire(\"./js/test/b.js\");// b.jsconsole.log(\"i am b\");// c.jsconsole.log(\"i am c\"); 我们要从 index.html 中利用 require.js 获取这一连串的依赖关系，一般采用的方式就是正则匹配。如下：先拿到 function 的代码，然后正则匹配出第一层的依赖关系，接着加载匹配到关系的代码，继续匹配。 1234567891011// index.html&lt;script type=\"text/javascript\" src=\"./js/require.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; function test()&#123; var a = require(\"./js/modlues/a.js\"); var c = require(\"./js/modlues/c.js\"); &#125; // toString 方法可以拿到 test 函数的 code start(test.toString());&lt;/script&gt; 整个函数的入口是 start，正则表达式为：1234567var r = /require\\((.*)\\)/g;var start = function(str)&#123; while(match = r.exec(str)) &#123; console.log(match[1]); &#125;&#125;; 由此我们拿到了第一层的依赖关系，1[\"./js/modlues/a.js\", \"./js/modlues/c.js\"] 接着要拿到 a.js 和 b.js 的文件层次依赖，之前我们写了一个 require 函数，这个函数可以拿到脚本的代码内容，不过这个 require 函数要稍微修改下，递归去查询和下载代码。 1234567891011121314151617181920212223var cache = &#123;&#125;;var start = function(str)&#123; while(match = r.exec(str)) &#123; console.log(match &amp;&amp; match[1]); // 如果匹配到了内容，下载 path 对应的源码 match &amp;&amp; match[1] &amp;&amp; require(match[1]); &#125;&#125;;var require = function(path)&#123; var xhr = new XMLHttpRequest(), res; xhr.open(\"GET\", path, true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; res = xhr.responseText; // 缓存文件 cache[path] = res; // 继续递归匹配 start(res); &#125; &#125; xhr.send();&#125;; 上面的代码已经可以很好地拿到文件递归关系了: 3. 添加事件机制，优化管理代码但是我们有必要先把 responseText 缓存起来，如果不缓存文件，直接 eval 得到的 responseText 代码，想想会发生什么问题~ 如果模块之间存在循环引用，如： 123 ┌&gt; a.js -&gt; b.jsindex.html -| └&gt; b.js -&gt; a.js 那 start 和 require 将会陷入死循环，不断的加载代码。所以我们需要先拿到依赖关系，然后解构关系，分析出我们需要加载哪些模块。值得注意的是，我们必须按照加载的顺序去 eval 代码，如果 a 依赖 b，先去执行 a 的话，一定会报错！ 有两个问题我纠结了半天，上面的请求方式，何时会结束？用什么方式去记录文件依赖关系？ 最后还是决定将 start 和 require 两个函数的相互递归修改成一个函数的递归。用一个对象，发起请求时把 URL 作为 key，在这个对象里保存 XHR 对象，XHR 对象请求完成后，把抓取到的新请求再用同样的方式放入这个对象中，同时从这个对象中把自己删除掉，然后判断这个对象上是否存在 key， 如果存在说明还有 XHR 对象没完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var r = /require\\(\\s*\"(.*)\"\\s*\\)/g;var cache = &#123;&#125;; // 文件缓存var relation = []; // 依赖过程控制var obj = &#123;&#125;; // xhr 管理对象//辅助函数，获取键值数组Object.keys = Object.keys || function(obj)&#123; var a = []; for(a[a.length] in obj); return a ;&#125;;// 入口函数function start(str)&#123; while(match = r.exec(str))&#123; obj[match[1]] = new XMLHttpRequest(); require(obj[match[1]], match[1]); &#125;&#125;// 递归请求var require = function(xhr, path)&#123; //记录依赖过程 relation.push(path); xhr.open(\"GET\", path, true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; var res = xhr.responseText; // 缓存文件 cache[path] = res; // 从xhr对象管理器中删除已经加载完毕的函数 delete obj[path]; // 如果obj为空则触发 allLoad 事件 Object.keys(obj).length == 0 ? Event.trigger(\"allLoad\") : void 0; //递归条件 while(match = r.exec(res))&#123; obj[match[1]] = new XMLHttpRequest(); require(obj[match[1]], match[1]); &#125; &#125; &#125; xhr.send();&#125;; 上面的代码已经基本完成了文件依赖分析，文件的加载和缓存工作了 CMD 规范的介绍 上面写了一大堆内容，也实现了模块加载器的原型，但是放在实际应用中，他就是个废品，回到最开始，我们为什么要使用模块化加载。目的是为了不去使用麻烦的命名空间，把复杂的模块依赖交给 require 这个函数去管理，但实际上呢，上面拿到的所有模块都是暴露在全局变量中的，也就是说，如果 a.js 和 b.js 中存在命名相同的变量，后者将会覆盖前者，这是我们不愿意看到的。为了处理此类问题，我们有必要把所有的模块都放到一个闭包中，这样一来，只要不使用 window.vars 命名，闭包之间的变量是不会相互影响的。我们可以使用自己的方式去管理代码，不过有人已经研究处理一套标准，而且是全球统一，那就拿着用吧~ 关于 CMD 规范，我这里就不多说了，可以去看看草案，玉伯也翻译了一份，戳我。每一模块有且仅有一个对外公开的接口 exports，如：123456789define(function(require, exports) &#123; // 对外提供 foo 属性 exports.foo = 'bar'; // 对外提供 doSomething 方法 exports.doSomething = function() &#123;&#125;;&#125;); 剩下的工作就是针对 CMD 规范写一套符合标准的代码接口，这个比较琐碎，就不写了。 二、额外的话题上面的代码中提到了关于 Event 的事件管理。在模块全部加在完毕之后，需要有个东西告诉你，所以顺手写了一个 Event 的事件管理器。12345678910111213141516171819202122232425262728293031// Eventvar Event = &#123;&#125;;Event.events = [];Event.on = function(evt, func)&#123; for(var i = 0; i &lt; Event.events.length; i++)&#123; if(Event.events[i].evt == evt)&#123; Event.events[i].func.push(func); return; &#125; &#125; Event.events.push(&#123; evt: evt, func: [func] &#125;);&#125;;Event.trigger = function(evt)&#123; for(var i = 0; i &lt; Event.events.length; i++)&#123; if(Event.events[i].evt == evt)&#123; for(var j = 0; j &lt; Event.events[i].func.length; j++)&#123; Event.events[i].func[j](); &#125; return; &#125; &#125;&#125;;Event.off = function(evt)&#123; for(var i = 0; i &lt; Event.events.length; i++)&#123; Event.events.splice(i, 1); &#125; &#125;; 我觉得 seajs 是一个很不错的模块加载器，如果感兴趣，可以去看看他的源码实现，代码不长，只有一千多行。模块的加载它采用的是创建文本节点，让文档去加载模块，实时查看状态为 interactive 的 script 标签，如果处于交互状态就拿到他的代码，接着删除节点。当节点数目为 0 的时候，加载工作完成。 本文没有考虑 css 文件的加载问题，我们可以把它当做一个没有 require 关键词的 js 文件，或者把它匹配出来之后另作处理，因为他是不可能存在模块依赖关系的。 三、参考资料seajs","categories":[],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://huayan.site/tags/模块化/"},{"name":"AMD","slug":"AMD","permalink":"http://huayan.site/tags/AMD/"},{"name":"CMD","slug":"CMD","permalink":"http://huayan.site/tags/CMD/"},{"name":"requirejs","slug":"requirejs","permalink":"http://huayan.site/tags/requirejs/"}]}]}