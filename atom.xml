<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>watson yan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huayan.site/"/>
  <updated>2017-10-25T14:02:14.000Z</updated>
  <id>http://huayan.site/</id>
  
  <author>
    <name>watson yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一小时掌握600个程序员词汇</title>
    <link href="http://huayan.site/2017/10/25/%E4%B8%80%E5%B0%8F%E6%97%B6%E6%8E%8C%E6%8F%A1600%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E8%AF%8D%E6%B1%87/"/>
    <id>http://huayan.site/2017/10/25/一小时掌握600个程序员词汇/</id>
    <published>2017-10-25T04:51:22.000Z</published>
    <updated>2017-10-25T14:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>function : 函式、函数 函数<br>application : 应用程式 应用、应用程序<br>architecture : 架构、系统架构 体系结构<br>argument : 引数（传给函式的值）。参见 parameter 参数、实质参数、实参、自变量<br>array : 阵列 数组<br>arrow operator arrow: （箭头）运算子 箭头操作符<br>assembly : 装配件<br>assembly language : 组合语言 汇编语言<br>assert(ion) : 断言<br>assign : 指派、指定、设值、赋值 赋值<br>assignment : 指派、指定 赋值、分配<br>assignment operator : 指派（赋值）运算子 = 赋值操作符<br>associated : 相应的、相关的 相关的、关联、相应的<br>associative container : 关联式容器（对应 sequential container） 关联式容器<br>atomic : 不可分割的 原子的<br>attribute : 属性 属性、特性<br>audio : 音讯 音频<br>A.I. : 人工智慧 人工智能<br>background : 背景 背景（用於图形着色） 后台（用於行程）<br>backward compatible : 回溯相容 向下兼容<br>bandwidth : 频宽 带宽<br>base class : 基础类别 基类<br>base type : 基础型别 (等同於 base class)<br>batch : 批次（意思是整批作业） 批处理<br>benefit : 利益 收益<br>best viable function : 最佳可行函式 最佳可行函式 （从 viable functions 中挑出的最佳吻合者）<br>binary search : 二分搜寻法 二分查找<br>binary tree : 二元树 二叉树<br>binary function : 二元函式 双参函数<br>binary operator : 二元运算子 二元操作符<br>binding : 系结 绑定<br>bit : 位元 位<br>bit field : 位元栏 位域<br>bitmap : 位元图 位图<br>bitwise : 以 bit 为单元逐一┅<br>bitwise copy : 以 bit 为单元进行复制；位元逐一复制 位拷贝<br>block : 区块,区段 块、区块、语句块<br>boolean : 布林值（真假值，true 或 false） 布尔值<br>border : 边框、框线 边框<br>brace(curly brace) : 大括弧、大括号 花括弧、花括号<br>bracket(square brakcet) : 中括弧、中括号 方括弧、方括号<br>breakpoint : 中断点 断点<br>build : 建造、构筑、建置（MS 用语）<br>build－in : 内建 内置<br>bus : 汇流排 总线<br>business : 商务,业务 业务<br>buttons : 按钮 按钮<br>byte : 位元组（由 8 bits 组成） 字节<br>cache : 快取 高速缓存<br>call : 呼叫、叫用 调用<br>callback : 回呼 回调<br>call operator call: （函式呼叫）运算子调用操作符 ###### （同 function call operator）<br>candidate function : 候选函式 候选函数 ###### （在函式多载决议程序中出现的候选函式）<br>chain : 串链（例 chain of function calls） 链<br>character : 字元 字符<br>check box : 核取方块 (i.e. check button) 复选框<br>checked exception : 可控式异常(Java)<br>check button : 方钮 (i.e. check box) 复选按钮<br>child class : 子类别（或称为derived class, subtype） 子类<br>class : 类别 类<br>class body : 类别本体 类体<br>class declaration : 类别宣告、类别宣告式 类声明<br>class definition : 类别定义、类别定义式 类定义<br>class derivation list : 类别衍化列 类继承列表<br>class head : 类别表头 类头<br>class hierarchy : 类别继承体系, 类别阶层 类层次体系<br>class library : 类别程式库、类别库 类库<br>class template : 类别模板、类别范本 类模板<br>class template partial specializations ###### : 类别模板偏特化 类模板部分特化<br>class template specializations ###### : 类别模板特化 类模板特化<br>cleanup : 清理、善后 清理、清除<br>client : 客端、客户端、客户 客户<br>client－server : 主从架构 客户/服务器<br>clipboard : 剪贴簿 剪贴板<br>clone : 复制 克隆<br>collection : 群集 集合<br>combo box : 复合方块、复合框 组合框<br>command line : 命令列 命令行 (系统文字模式下的整行执行命令)<br>communication : 通讯 通讯<br>compatible : 相容 兼容<br>compile time : 编译期 编译期、编译时<br>compiler : 编译器 编译器<br>component : 组件 组件<br>composition : 复合、合成、组合 组合<br>computer : 电脑、计算机 计算机、电脑<br>concept : 概念 概念<br>concrete : 具象的 实在的<br>concurrent : 并行 并发<br>configuration : 组态 配置<br>connection : 连接，连线（网络,资料库） 连接<br>constraint : 约束（条件）<br>construct : 构件 构件<br>container : 容器 容器 ###### （存放资料的某种结构如 list, vector…）<br>containment : 内含 包容<br>context : 背景关系、周遭环境、上下脉络 环境、上下文<br>control : 控制元件、控件 控件<br>console : 主控台 控制台<br>const : 常数（constant 的缩写，C++ 关键字）<br>constant : 常数（相对於 variable） 常量<br>constructor : 建构式 构造函数 ###### （与class 同名的一种 member functions）<br>copy: 动词：复制、拷贝 拷贝<br>copy: 名词：复件, 副本<br>cover : 涵盖 覆盖<br>create : 创建、建立、产生、生成 创建<br>creation : 产生、生成 创建<br>cursor : 游标 光标<br>custom : 订制、自定 定制<br>data : 资料 数据<br>database : 资料库 数据库<br>database schema : 数据库结构纲目<br>data member : 资料成员、成员变数 数据成员、成员变量<br>data structure : 资料结构 数据结构<br>datagram : 资料元 数据报文<br>dead lock : 死结 死锁<br>debug : 除错 调试<br>debugger : 除错器 调试器<br>declaration : 宣告、宣告式 声明<br>deduction : 推导（例：template argument deduction） 推导、推断<br>default : 预设 缺省、默认<br>defer : 延缓 推迟<br>define : 定义 预定义<br>definition : 定义、定义区、定义式 定义<br>delegate : 委派、委托、委任 委托<br>delegation : （同上）<br>demarshal : 反编列 散集<br>dereference : 提领（取出指标所指物体的内容） 解参考<br>dereference operator dereference: （提领）运算子 <em> 解参考操作符<br>derived class : 衍生类别 派生类<br>design by contract : 契约式设计<br>design pattern : 设计范式、设计样式 设计模式 ※ 最近我比较喜欢「设计范式」一词<br>destroy : 摧毁、销毁<br>destructor : 解构式 析构函数<br>device : 装置、设备 设备<br>dialog : 对话窗、对话盒 对话框<br>directive : 指令（例：using directive） (编译)指示符<br>directory : 目录 目录<br>disk : 碟 盘<br>dispatch : 分派 分派<br>distributed computing : 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算)<br>document : 文件 文档<br>dot operator dot: （句点）运算子 . (圆)点操作符<br>driver : 驱动程式 驱动（程序）<br>dynamic binding : 动态系结 动态绑定<br>efficiency : 效率 效率<br>efficient : 高效 高效<br>end user : 终端用户<br>entity : 物体 实体、物体<br>encapsulation : 封装 封装<br>enclosing class : 外围类别（与巢状类别 nested class 有关）外围类<br>enum (enumeration) : 列举（一种 C++ 资料型别） 枚举<br>enumerators : 列举元（enum 型别中的成员） 枚举成员、枚举器<br>equal : 相等 相等<br>equality : 相等性 相等性<br>equality operator equality: （等号）运算子 == 等号操作符<br>equivalence : 等价性、等同性、对等性 等价性<br>equivalent : 等价、等同、对等 等价<br>escape code : 转义码 转义码<br>evaluate : 评估、求值、核定 评估<br>event : 事件 事件<br>event driven : 事件驱动的 事件驱动的<br>exception : 异常情况 异常<br>exception declaration : 异常宣告（ref. C++ Primer 3/e, 11.3） 异常声明<br>exception handling : 异常处理、异常处理机制 异常处理、异常处理机制<br>exception specification : 异常规格（ref. C++ Primer 3/e, 11.4） 异常规范<br>exit : 退离（指离开函式时的那一个执行点） 退出<br>explicit : 明白的、明显的、显式 显式<br>export : 汇出 引出、导出<br>expression : 运算式、算式 表达式<br>facility : 设施、设备 设施、设备<br>feature : 特性<br>field : 栏位,资料栏（Java） 字段, 值域（Java）<br>file : 档案 文件<br>firmware : 韧体 固件<br>flag : 旗标 标记<br>flash memory : 快闪记忆体 闪存<br>flexibility : 弹性 灵活性<br>flush : 清理、扫清 刷新<br>font : 字型 字体<br>form : 表单（programming 用语） 窗体<br>formal parameter : 形式参数 形式参数<br>forward declaration : 前置宣告 前置声明<br>forwarding : 转呼叫,转发 转发<br>forwarding function : 转呼叫函式,转发函式 转发函数<br>fractal : 碎形 分形<br>framework : 框架 框架<br>full specialization : 全特化（ref. partial specialization）<br>function : 函式、函数 函数<br>function call operator : 同 call operator<br>function object : 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象<br>function overloaded resolution : 函式多载决议程序 函数重载解决（方案）<br>functionality : 功能、机能 功能<br>function template : 函式模板、函式范本 函数模板<br>functor : 仿函式 仿函式、函子<br>game : 游戏 游戏<br>generate : 生成<br>generic : 泛型、一般化的 一般化的、通用的、泛化<br>generic algorithm : 泛型演算法 通用算法<br>getter:  (相对於 setter) 取值函式<br>global : 全域的（对应於 local） 全局的<br>global object : 全域物件 全局对象<br>global scope resolution operator : 全域生存空间（范围决议）运算子 :: 全局范围解析操作符<br>group : 群组<br>group box : 群组方块 分组框<br>guard clause : 卫述句 (Refactoring, p250) 卫语句<br>GUI : 图形介面 图形界面<br>hand shaking : 握手协商<br>handle : 识别码、识别号、号码牌、权柄 句柄<br>handler : 处理常式 处理函数<br>hard－coded : 编死的 硬编码的<br>hard－copy : 硬拷图 屏幕截图<br>hard disk : 硬碟 硬盘<br>hardware : 硬体 硬件<br>hash table : 杂凑表 哈希表、散列表<br>header file : 表头档、标头档 头文件<br>heap : 堆积 堆<br>hierarchy : 阶层体系 层次结构（体系）<br>hook : 挂钩 钩子<br>hyperlink : 超链结 超链接<br>icon : 图示、图标 图标<br>IDE : 整合开发环境 集成开发环境<br>identifier : 识别字、识别符号 标识符<br>if and only if : 若且唯若 当且仅当<br>Illinois : 伊利诺 伊利诺斯<br>image : 影像 图象<br>immediate base : 直接的（紧临的）上层 base class。 直接上层基类<br>immediate derived : 直接的（紧临的）下层 derived class。 直接下层派生类<br>immutability : 不变性<br>immutable : 不可变（的）<br>implement : 实作、实现 实现<br>implementation : 实作品、实作体、实作码、实件 实现<br>implicit : 隐喻的、暗自的、隐式 隐式<br>import : 汇入 导入<br>increment operator : 累加运算子 ++ 增加操作符<br>infinite loop : 无穷回圈 无限循环<br>infinite recursive : 无穷递回 无限递归<br>information : 资讯 信息<br>infrastructure : 公共基础建设<br>inheritance : 继承、继承机制 继承、继承机制<br>inline : 行内 内联<br>inline expansion : 行内展开 内联展开<br>initialization : 初始化（动作） 初始化<br>initialization list : 初值列 初始值列表<br>initialize : 初始化 初始化<br>inner class : 内隐类别 内嵌类<br>instance : 实体 实例 ###### （根据某种表述而实际产生的「东西」）<br>instantiated : 具现化、实体化（常应用於 template） 实例化<br>instantiation : 具现体、具现化实体（常应用於 template） 实例<br>integer (integral) : 整数（的） 整型（的）<br>integrate : 整合 集成<br>interacts : 交谈、互动 交互<br>interface : 介面 接口<br>for GUI : 介面 界面<br>interpreter : 直译器 解释器<br>invariants : 恒常性,约束条件 约束条件<br>invoke : 唤起 调用<br>iterate : 迭代（回圈一个轮回一个轮回地进行） 迭代<br>exception : 异常情况 异常<br>exception declaration : 异常宣告（ref. C++ Primer 3/e, 11.3） 异常声明<br>exception handling : 异常处理、异常处理机制 异常处理、异常处理机制<br>exception specification : 异常规格（ref. C++ Primer 3/e, 11.4） 异常规范<br>exit : 退离（指离开函式时的那一个执行点） 退出<br>explicit : 明白的、明显的、显式 显式<br>export : 汇出 引出、导出<br>expression : 运算式、算式 表达式<br>facility : 设施、设备 设施、设备<br>feature : 特性<br>field : 栏位,资料栏（Java） 字段, 值域（Java）<br>file : 档案 文件<br>firmware : 韧体 固件<br>flag : 旗标 标记<br>flash memory : 快闪记忆体 闪存<br>flexibility : 弹性 灵活性<br>flush : 清理、扫清 刷新<br>font : 字型 字体<br>form : 表单（programming 用语） 窗体<br>formal parameter : 形式参数 形式参数<br>forward declaration : 前置宣告 前置声明<br>forwarding : 转呼叫,转发 转发<br>forwarding function : 转呼叫函式,转发函式 转发函数<br>fractal : 碎形 分形<br>framework : 框架 框架<br>full specialization : 全特化（ref. partial specialization）<br>application framework : 应用程式框架、应用框架 应用程序框架<br>function call operator : 同 call operator<br>function object : 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象<br>function overloaded resolution : 函式多载决议程序 函数重载解决（方案）<br>functionality : 功能、机能 功能<br>function template : 函式模板、函式范本 函数模板<br>functor : 仿函式 仿函式、函子<br>game : 游戏 游戏<br>generate : 生成<br>generic : 泛型、一般化的 一般化的、通用的、泛化<br>generic algorithm : 泛型演算法 通用算法<br>getter (: 相对於 setter) 取值函式<br>global : 全域的（对应於 local） 全局的<br>global object : 全域物件 全局对象<br>global scope resolution operator : 全域生存空间（范围决议）运算子 :: 全局范围解析操作符<br>group : 群组<br>group box : 群组方块 分组框<br>guard clause : 卫述句 (Refactoring, p250) 卫语句<br>GUI : 图形介面 图形界面<br>hand shaking : 握手协商<br>handle : 识别码、识别号、号码牌、权柄 句柄<br>handler : 处理常式 处理函数<br>hard－coded : 编死的 硬编码的<br>hard－copy : 硬拷图 屏幕截图<br>hard disk : 硬碟 硬盘<br>hardware : 硬体 硬件<br>hash table : 杂凑表 哈希表、散列表<br>header file : 表头档、标头档 头文件<br>heap : 堆积 堆<br>hierarchy : 阶层体系 层次结构（体系）<br>hook : 挂钩 钩子<br>hyperlink : 超链结 超链接<br>icon : 图示、图标 图标<br>IDE : 整合开发环境 集成开发环境<br>identifier : 识别字、识别符号 标识符<br>if and only if : 若且唯若 当且仅当<br>Illinois : 伊利诺 伊利诺斯<br>image : 影像 图象<br>immediate base : 直接的（紧临的）上层 base class。 直接上层基类<br>immediate derived : 直接的（紧临的）下层 derived class。 直接下层派生类<br>immutability : 不变性<br>immutable : 不可变（的）<br>implement : 实作、实现 实现<br>implementation : 实作品、实作体、实作码、实件 实现<br>implicit : 隐喻的、暗自的、隐式 隐式<br>import : 汇入 导入<br>increment operator : 累加运算子 ++ 增加操作符<br>infinite loop : 无穷回圈 无限循环<br>infinite recursive : 无穷递回 无限递归<br>information : 资讯 信息<br>infrastructure : 公共基础建设<br>inheritance : 继承、继承机制 继承、继承机制<br>inline : 行内 内联<br>inline expansion : 行内展开 内联展开<br>initialization : 初始化（动作） 初始化<br>initialization list : 初值列 初始值列表<br>initialize : 初始化 初始化<br>inner class : 内隐类别 内嵌类<br>instance : 实体 实例 ###### （根据某种表述而实际产生的「东西」）<br>instantiated : 具现化、实体化（常应用於 template） 实例化<br>instantiation : 具现体、具现化实体（常应用於 template） 实例<br>integer (integral) : 整数（的） 整型（的）<br>integrate : 整合 集成<br>interacts : 交谈、互动 交互<br>interface : 介面 接口<br>for GUI : 介面 界面<br>interpreter : 直译器 解释器<br>invariants : 恒常性,约束条件 约束条件<br>invoke : 唤起 调用<br>iterate : 迭代（回圈一个轮回一个轮回地进行） 迭代<br>iterative : 反覆的，迭代的<br>iterator : 迭代器（一种泛型指标） 迭代器<br>iteration : 迭代（回圈每次轮回称为一个 iteration） 迭代<br>item : 项目、条款 项、条款、项目<br>laser : 雷射 激光<br>level : 阶 层 (级) 例 high level 高阶 高层<br>library : 程式库、函式库 库、函数库<br>lifetime : 生命期、寿命 生命期、寿命<br>link : 联结、连结 连接,链接<br>linker : 联结器、连结器 连接器<br>literal constant : 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数<br>list : 串列（linked－list） 列表、表、链表<br>list box : 列表方块、列表框 列表框<br>load : 载入 装载<br>loader : 载入器 装载器、载入器<br>local : 区域的（对应於 global） 局部的<br>local object : 区域物件 局部对象<br>lock : 机锁<br>loop : 回圈 循环<br>lvalue : 左值 左值<br>macro : 巨集 宏<br>magic number : 魔术数字 魔法数<br>maintain : 维护 维护<br>manipulator : 操纵器（iostream 预先定义的一种东西） 操纵器<br>marshal : 编列 列集 参考 demarshal<br>mechanism : 机制 机制<br>member : 成员 成员<br>member access operator : 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符<br>member function : 成员函式 成员函数<br>member initialization list : 成员初值列 成员初始值列表<br>memberwise : 以 member 为单元┅、members 逐一┅ 以成员为单位<br>memberwise copy : 以 members 为单元逐一复制<br>memory : 记忆体 内存<br>menu : 表单、选单 菜单<br>message : 讯息 消息<br>message based : 以讯息为基础的 基於消息的<br>message loop : 讯息回圈 消息环<br>method (java) : 方法、行为、函式 方法<br>meta－ : 超－ 元－ 例 meta－programming 超编程 元编程<br>micro : 微 微<br>middleware : 中介层 中间件<br>modeling : 模塑<br>modeling language : 塑模语言，建模语言<br>modem : 数据机 调制解调器<br>module : 模组 模块<br>modifier : 饰词 修饰符<br>most derived class : 最末层衍生类别 最底层的派生类<br>mouse : 滑鼠 鼠标<br>mutable : 可变的 可变的<br>multi－tasking : 多工 多任务<br>namespace : 命名空间 名字空间、命名空间<br>native : 原生的 本地的、固有的<br>nested class : 巢状类别 嵌套类<br>network : 网路 网络<br>network card : 网路卡 网卡<br>object : 物件 对象<br>object based : 以物件为基础的 基於对象的<br>object file : 目的档 目标文件<br>object model : 物件模型 对象模型<br>object oriented : 物件导向的 面向对象的<br>online : 线上 在线<br>opaque : 不透明的<br>operand : 运算元 操作数<br>operating system (OS) : 作业系统 操作系统<br>operation : 操作、操作行为 操作<br>operator : 运算子 操作符、运算符<br>option : 选项，可选方案 选项<br>ordinary : 常规的 常规的<br>overflow : 上限溢位（相对於 underflow） 溢出（underflow:下溢）<br>overhead : 额外负担、额外开销 额外开销<br>overload : 多载化、多载化、重载 重载<br>overloaded function : 多载化函式 重载的函数<br>overloaded operator : 多载化运算子 被重载的操作符<br>overloaded set : 多载集合 重载集合<br>override : 改写、覆写 重载、改写、重新定义 ###### （在 derived class 中重新定义虚拟函式<br>package : 套件 包<br>pair : 对组<br>palette : 调色盘、组件盘、工具箱<br>pane : 窗格 窗格 ###### （有时为嵌板之意，例 Java Content Pane）<br>parallel : 平行 并行<br>parameter : 参数（函式参数列上的变数） 参数、形式参数、形参<br>parameter list : 参数列 参数列表<br>parent class : 父类别（或称 base class） 父类<br>parentheses : 小括弧、小括号 圆括弧、圆括号<br>parse : 解析 解析<br>part : 零件 部件<br>partial specialization : 偏特化（ref. C++ Primer 3/e, 16.10） 局部特化 ###### （ref. full specialization）<br>pass by address : 传址（函式引数的传递方式）（非正式用语）传地址<br>pass by reference : 传址（函式引数的一种传递方式） 传地址, 按引用传递<br>pass by value : 传值（函式引数的一种传递方式） 按值传递<br>pattern : 范式、样式 模式<br>performance : 效率、性能兼而有之 性能<br>persistence : 永续性 持久性<br>pixel : 图素、像素 像素<br>placement delete ref. C++ Primer 3/e, 15.8.: 2<br>placement new ref. C++ Primer 3/e, 15.8.: 2<br>platform : 平台 平台<br>pointer : 指标 指针 址位器（和址参器 reference 形成对映，满好）<br>poll : 轮询 轮询<br>polymorphism : 多型 多态<br>pop up : 冒起式、弹出式 弹出式<br>port : 埠 端口<br>postfix : 后置式、后序式 后置式<br>precedence : 优先序（通常用於运算子的优先执行次序）<br>prefix : 前置式、前序式 前置式<br>preprocessor : 前处理器 预处理器<br>prime : 质数 素数<br>primitive type : 基本型别 (不同於 base class,基础类别)<br>print : 列印 打印<br>printer : 印表机 打印机<br>priority : 优先权 (通常用於执行绪获得 CPU 时间的优先次序）<br>procedure : 程序 过程<br>procedural : 程序性的、程序式的 过程式的、过程化的<br>process : 行程 进程<br>profile : 评测 评测<br>profiler : 效能（效率）评测器 效能（性能）评测器<br>programmer : 程式员 程序员<br>programming : 编程、程式设计、程式化 编程<br>progress bar : 进度指示器 进度指示器<br>project : 专案 项目、工程<br>property : 属性<br>protocol : 协定 协议<br>pseudo code : 假码、虚拟码、伪码 伪码<br>qualified : 经过资格修饰（例如加上 scope 运算子） 限定<br>qualifier : 资格修饰词、饰词 限定修饰词<br>quality : 品质 质量<br>queue : 伫列 队列<br>radian : 径度 弧度<br>radio button : 圆钮 单选按钮<br>raise : 引发（常用来表示发出一个 exception） 引起、引发<br>random number : 随机数、乱数 随机数<br>range : 范围、区间（用於 STL 时） 范围、区间<br>rank : 等级、分等（ref. C++Primer 3/e 9,15章） 等级<br>raw : 生鲜的、未经处理的 未经处理的<br>record : 记录 记录<br>recordset : 记录集 记录集<br>recursive : 递回 递归<br>re－direction : 重导向 重定向<br>refactoring : 重构、重整 重构<br>refer : 取用 参考<br>refer to : 指向、指涉、指代<br>reference  : （C++中类似指标的东西，相当於 “化身”） 引用、参考 址参器, see pointer<br>register : 暂存器 寄存器<br>reflection : 反射 反射、映像<br>relational database : 关联式资料库 关系数据库<br>represent : 表述，表现 表述，表现<br>resolve : 决议（为算式中的符号名称寻找 解析 对应之宣告式的过程）<br>resolution : 决议程序、决议过程 解析过程<br>resolution : 解析度 分辨率<br>restriction : 局限<br>return : 传回、回返 返回<br>return type : 回返型别 返回类型<br>return value : 回返值 返回值<br>robust : 强固、稳健 健壮<br>robustness : 强固性、稳健性 健壮性<br>routine : 常式 例程<br>runtime : 执行期 运行期、运行时<br>common language runtime : (CLR)译为「通用语言执行层」<br>rvalue : 右值 右值<br>save : 储存 存储<br>schedule : 排程 调度<br>scheduler : 排程器 调度程序<br>scheme : 结构纲目、组织纲目<br>scroll bar : 卷轴 滚动条<br>scope : 生存空间、生存范围、范畴、作用域 生存空间<br>scope operator : 生存空间（范围决议）运算子 :: 生存空间操作符<br>scope resolution operator : 生存空间决议运算子 生存空间解析操作符 ###### （与scope operator同）<br>screen : 萤幕 屏幕<br>search : 搜寻 查找<br>semantics : 语意 语义<br>sequential container : 序列式容器 顺序式容器 ###### （对应於 associative container）<br>server : 伺服器、伺服端 服务器、服务端<br>serial : 串行<br>serialization : 次第读写,序列化 序列化 (serialize)<br>setter (: 相对於 getter) 设值函式<br>signal : 信号<br>signature : 标记式、签名式、署名式 签名<br>slider : 滚轴 滑块<br>slot : 条孔、槽 槽<br>smart pointer : 灵巧指标、精灵指标 智能指针<br>snapshot : 萤幕快照（图） 屏幕截图<br>specialization : 特殊化、特殊化定义、特殊化宣告 特化<br>specification : 规格 规格、规范<br>splitter : 分裂视窗 切分窗口<br>software : 软体 软件<br>solution : 解法,解决方案 方案<br>source : 原始码 源码、源代码<br>stack : 堆叠 栈<br>stack unwinding : 堆叠辗转开解（此词用於 exception 主题） 栈辗转开解 </em><br>standard library : 标准程式库<br>standard template library : 标准模板程式库<br>statement : 述句 语句、声明<br>status bar : 状态列、状态栏 状态条<br>STL : 见 standard template library<br>stream : 资料流、串流 流<br>string : 字串 字符串<br>subroutin: e<br>subscript operator : 下标运算子 [ ] 下标操作符<br>subtype : 子型别 子类型<br>support : 支援 支持<br>suspend : 虚悬 挂起<br>symbol : 符号 记号<br>syntax : 语法 语法<br>tag : 标签 标记 索引标签,页签<br>target : 标的（例 target pointer：标的指标） 目标<br>task switch : 工作切换 任务切换<br>template : 模板、范本 模板<br>template argument deduction : 模板引数推导 模板参数推导<br>template explicit specialization : 模板显式特化（版本） 模板显式特化<br>template parameter : 模板参数 模板参数<br>temporary object : 暂时物件 临时对象<br>text : 文字 文本</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;function : 函式、函数 函数&lt;br&gt;application : 应用程式 应用、应用程序&lt;br&gt;architecture : 架构、系统架构 体系结构&lt;br&gt;argument : 引数（传给函式的值）。参见 parameter 参数、实质参数、实参、自变量&lt;br&gt;
    
    </summary>
    
    
      <category term="单词" scheme="http://huayan.site/tags/%E5%8D%95%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现继承</title>
    <link href="http://huayan.site/2017/10/18/Javascript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
    <id>http://huayan.site/2017/10/18/Javascript实现继承/</id>
    <published>2017-10-18T04:51:22.000Z</published>
    <updated>2017-10-18T09:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 segmentful<a href="https://segmentfault.com/a/1190000002440502" target="_blank" rel="external">trigkit4</a></p>
<h2 id="js继承的概念"><a href="#js继承的概念" class="headerlink" title="js继承的概念"></a>js继承的概念</h2><p>js里常用的如下两种继承方式：</p>
<ul>
<li>原型链继承（对象间的继承）</li>
<li>类式继承（构造函数间的继承）</li>
</ul>
<p>由于js不像java那样是真正面向对象的语言，js是基于对象的，它没有类的概念。所以，要想实现继承，可以用js的原型prototype机制或者用apply和call方法去实现</p>
<p>在面向对象的语言中，我们使用类来创建一个自定义对象。然而js中所有事物都是对象，那么用什么办法来创建自定义对象呢？这就需要用到js的原型：</p>
<p>我们可以简单的把prototype看做是一个模版，新创建的自定义对象都是这个模版（prototype）的一个拷贝 （实际上不是拷贝而是链接，只不过这种链接是不可见，新实例化的对象内部有一个看不见的<strong>Proto</strong>指针，指向原型对象）。</p>
<p>js可以通过构造函数和原型的方式模拟实现类的功能。 另外，js类式继承的实现也是依靠原型链来实现的。</p>
<h2 id="原型式继承与类式继承"><a href="#原型式继承与类式继承" class="headerlink" title="原型式继承与类式继承"></a>原型式继承与类式继承</h2><p>类式继承是在子类型构造函数的内部调用超类型的构造函数。<br>严格的类式继承并不是很常见，一般都是组合着用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.colors=[<span class="string">"red"</span>,<span class="string">"blue"</span>];</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原型式继承是借助已有的对象创建新的对象，将子类的原型指向父类，就相当于加入了父类这条原型链</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>为了让子类继承父类的属性（也包括方法），首先需要定义一个构造函数。然后，将父类的新实例赋值给构造函数的原型。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'mike'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">12</span>;</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//Child继承Parent，通过原型，形成链条</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Child();</div><div class="line">alert(test.age);</div><div class="line">alert(test.name);<span class="comment">//得到被继承的属性</span></div><div class="line"><span class="comment">//继续原型链继承</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Brother</span>(<span class="params"></span>)</span>&#123;   <span class="comment">//brother构造</span></div><div class="line">    <span class="keyword">this</span>.weight = <span class="number">60</span>;</div><div class="line">&#125;</div><div class="line">Brother.prototype = <span class="keyword">new</span> Child();<span class="comment">//继续原型链继承</span></div><div class="line"><span class="keyword">var</span> brother = <span class="keyword">new</span> Brother();</div><div class="line">alert(brother.name);<span class="comment">//继承了Parent和Child,弹出mike</span></div><div class="line">alert(brother.age);<span class="comment">//弹出12</span></div></pre></td></tr></table></figure>
<p>以上原型链继承还缺少一环，那就是Object，所有的构造函数都继承自Object。而继承Object是自动完成的，并不需要我们自己手动继承，那么他们的从属关系是怎样的呢？</p>
<h3 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><p>可以通过两种方式来确定原型和实例之间的关系。操作符<em>instanceof</em>和<em>isPrototypeof()</em>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(brother <span class="keyword">instanceof</span> <span class="built_in">Object</span>)<span class="comment">//true</span></div><div class="line">alert(test <span class="keyword">instanceof</span> Brother);<span class="comment">//false,test 是brother的超类</span></div><div class="line">alert(brother <span class="keyword">instanceof</span> Child);<span class="comment">//true</span></div><div class="line">alert(brother <span class="keyword">instanceof</span> Parent);<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型，因此，isPrototypeof()方法也会返回true</p>
<p>在js中，被继承的函数称为超类型（父类，基类也行），继承的函数称为子类型（子类，派生类）。使用原型继承主要由两个问题：<br>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</p>
<p>伪类解决引用共享和超类型无法传参的问题，我们可以采用“借用构造函数”技术</p>
<h3 id="借用构造函数（类式继承）"><a href="#借用构造函数（类式继承）" class="headerlink" title="借用构造函数（类式继承）"></a>借用构造函数（类式继承）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = [<span class="string">'mike'</span>,<span class="string">'jack'</span>,<span class="string">'smith'</span>];</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>)</span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>,age);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Child(<span class="number">21</span>);</div><div class="line">alert(test.age);<span class="comment">//21</span></div><div class="line">alert(test.name);<span class="comment">//mike,jack,smith</span></div><div class="line">test.name.push(<span class="string">'bill'</span>);</div><div class="line">alert(test.name);<span class="comment">//mike,jack,smith,bill</span></div></pre></td></tr></table></figure>
<p>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起，所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = [<span class="string">'mike'</span>,<span class="string">'jack'</span>,<span class="string">'smith'</span>];</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">Parent.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name  + <span class="string">' are both'</span> + <span class="keyword">this</span>.age;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>)</span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>,age);<span class="comment">//对象冒充，给超类型传参</span></div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//原型链继承</span></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Child(<span class="number">21</span>);<span class="comment">//写new Parent(21)也行</span></div><div class="line">alert(test.run());<span class="comment">//mike,jack,smith are both21</span></div></pre></td></tr></table></figure>
<p>组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p>
<blockquote>
<p>call()的用法：调用一个对象的一个方法，以另一个对象替换当前对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call([thisObj[,arg1[, arg2[, [,.argN]]]]])</div></pre></td></tr></table></figure>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>这种继承借助原型并基于已有的对象创建新对象，同时还不用创建自定义类型的方式称为原型式继承<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> box = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">'trigkit4'</span>,</div><div class="line">    <span class="attr">arr</span> : [<span class="string">'brother'</span>,<span class="string">'sister'</span>,<span class="string">'baba'</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> b1 = obj(box);</div><div class="line">alert(b1.name);<span class="comment">//trigkit4</span></div><div class="line"></div><div class="line">b1.name = <span class="string">'mike'</span>;</div><div class="line">alert(b1.name);<span class="comment">//mike</span></div><div class="line"></div><div class="line">alert(b1.arr);<span class="comment">//brother,sister,baba</span></div><div class="line">b1.arr.push(<span class="string">'parents'</span>);</div><div class="line">alert(b1.arr);<span class="comment">//brother,sister,baba,parents</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b2 = obj(box);</div><div class="line">alert(b2.name);<span class="comment">//trigkit4</span></div><div class="line">alert(b2.arr);<span class="comment">//brother,sister,baba,parents</span></div></pre></td></tr></table></figure></p>
<p>原型式继承首先在obj()函数内部创建一个临时性的构造函数 ，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>这种继承方式是把原型式+工厂模式结合起来，目的是为了封装创建的过程。</p>
<pre><code>function create(o){
    var f= obj(o);
    f.run = function () {
        return this.arr;//同样，会共享引用
    };
    return f;
}
</code></pre><h3 id="组合式继承的小问题"><a href="#组合式继承的小问题" class="headerlink" title="组合式继承的小问题"></a>组合式继承的小问题</h3><p>组合式继承是js最常用的继承模式，但组合继承的超类型在使用过程中会被调用两次；一次是创建子类型的时候，另一次是在子类型构造函数的内部</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.arr = [<span class="string">'哥哥'</span>,<span class="string">'妹妹'</span>,<span class="string">'父母'</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Parent.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>,age);<span class="comment">//第二次调用</span></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//第一次调用</span></div></pre></td></tr></table></figure>
<p>以上代码是之前的组合继承，那么寄生组合继承，解决了两次调用的问题。</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">parent,test</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> f = obj(parent.prototype);<span class="comment">//创建对象</span></div><div class="line">    f.constructor = test;<span class="comment">//增强对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.arr = [<span class="string">'brother'</span>,<span class="string">'sister'</span>,<span class="string">'parents'</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Parent.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.age =age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(Parent,Child);<span class="comment">//通过这里实现继承</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Child(<span class="string">'trigkit4'</span>,<span class="number">21</span>);</div><div class="line">test.arr.push(<span class="string">'nephew'</span>);</div><div class="line">alert(test.arr);<span class="comment">//</span></div><div class="line">alert(test.run());<span class="comment">//只共享了方法</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> test2 = <span class="keyword">new</span> Child(<span class="string">'jack'</span>,<span class="number">22</span>);</div><div class="line">alert(test2.arr);<span class="comment">//引用问题解决</span></div></pre></td></tr></table></figure>
<h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><p>全局函数apply和call可以用来改变函数中this的指向，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个全局函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.fruit);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义一个全局变量</span></div><div class="line"><span class="keyword">var</span> fruit = <span class="string">"apple"</span>;</div><div class="line"><span class="comment">// 自定义一个对象</span></div><div class="line"><span class="keyword">var</span> pack = &#123;</div><div class="line">    <span class="attr">fruit</span>: <span class="string">"orange"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 等价于window.foo();</span></div><div class="line">foo.apply(<span class="built_in">window</span>);  <span class="comment">// "apple",此时this等于window</span></div><div class="line"><span class="comment">// 此时foo中的this === pack</span></div><div class="line">foo.apply(pack);    <span class="comment">// "orange"</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自 segmentful&lt;a href=&quot;https://segmentfault.com/a/1190000002440502&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;trigkit4&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;js继承的概念&quot;&gt;&lt;a h
    
    </summary>
    
    
      <category term="Javascript" scheme="http://huayan.site/tags/Javascript/"/>
    
      <category term="继承" scheme="http://huayan.site/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包</title>
    <link href="http://huayan.site/2017/10/12/JavaScript%E9%97%AD%E5%8C%85/"/>
    <id>http://huayan.site/2017/10/12/JavaScript闭包/</id>
    <published>2017-10-12T04:51:22.000Z</published>
    <updated>2017-10-11T08:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>JavaScript的闭包是一个特色。官方解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。这句话相信有许多人看不懂。我来表述一下我对JavaScript闭包的理解：<br>闭包的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count=<span class="number">10</span>;<span class="comment">//全局作用域 标记为flag1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> count=<span class="number">0</span>;<span class="comment">//函数全局作用域 标记为flag2</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        count+=<span class="number">1</span>;<span class="comment">//函数的内部作用域</span></div><div class="line">        alert(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> s=add()</div><div class="line">s();<span class="comment">//输出1</span></div><div class="line">s();<span class="comment">//输出2</span></div></pre></td></tr></table></figure></p>
<p>add()的返回值是一个函数，首先第一次调用s()的时候，是执行add()的返回的函数，也就是下面这个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	count+=<span class="number">1</span>;<span class="comment">//函数的内部作用域</span></div><div class="line">	alert(count);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是将count+1，在输出，那count是从哪儿来的的呢，根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined。这里明显count 是函数内部的flag2 的那个count ，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count=<span class="number">10</span>;<span class="comment">//全局作用域</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//var count=0;注释掉了</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        count+=<span class="number">1</span>;<span class="comment">//函数的内部作用域</span></div><div class="line">        alert(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> s=add()</div><div class="line">s();<span class="comment">//输出11</span></div><div class="line">s();<span class="comment">//输出12</span></div></pre></td></tr></table></figure></p>
<p>自然这是体现不出闭包的性质，只为了说明函数作用域链 继续说明：第一次执行，是没有疑问的输出1，那第二次的过程是怎样的呢？ 继续执行那个函数的返回的方法，还是count+=1;然后再输出count ，这里问题就来了，不应该继续向上寻找，找到count=0；然后输出1吗？不知道有没有注意一个问题，那就是s()执行的是下面这个函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    count+=<span class="number">1</span>;<span class="comment">//函数的内部作用域</span></div><div class="line">    alert(count);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是说add()，只被执行了一次。然后执行两次s()，那count的值就是只声明了一次。<br>var s=add()，函数add 只在这里执行了一次。<br>下面执行的都是s()，那第二次的count的值是从哪儿来的，没错它还是第一次执行add时，留下来的那个变量。<br>（这怎么可能，函数变量执行完就会被释放啊，为什么还在？这里就是一个垃圾回收机制的引用计数问题）。<br>“”如果一个变量的引用不为0，那么他不会被垃圾回收机制回收，引用，就是被调用“”。<br>由于再次执行s()的时候，再次引用了第一次add()产生的变量count ，所以count没有被释放，第一次s(),count 的值为1,第二次执行s()，count的值再加1，自然就是2了。<br>让我们返回来再看看，根据以上所说，如果执行两次add() ，那就应该输出 都是1，来改一下这个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> count=<span class="number">0</span>;<span class="comment">//函数全局作用域</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        count+=<span class="number">1</span>;<span class="comment">//函数的内部作用域</span></div><div class="line">        alert(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">add()();<span class="comment">//输出1</span></div><div class="line">add()();<span class="comment">//输出1</span></div></pre></td></tr></table></figure>
<p>果真如此。输出的两次都是1.<br>另外，我觉得阮一峰说的闭包也是很简洁的：“我的理解是，闭包就是能够读取其他函数内部变量的函数。”</p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。<br>变量的作用域无非就是两种：全局变量和局部变量。<br>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。<br>Js代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(n);</div><div class="line">&#125;</div><div class="line">f1(); <span class="comment">// 999</span></div></pre></td></tr></table></figure></p>
<p>另一方面，在函数外部自然无法读取函数内的局部变量。<br>Js代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">&#125;</div><div class="line">alert(n); <span class="comment">// error</span></div></pre></td></tr></table></figure>
<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！<br>Js代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    n=<span class="number">999</span>;</div><div class="line">&#125;</div><div class="line">f1();</div><div class="line">alert(n); <span class="comment">// 999</span></div></pre></td></tr></table></figure>
<p>有时候需要得到函数内的局部变量，在函数的内部，再定义一个函数。<br>Js代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　n=<span class="number">999</span>;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　alert(n); <span class="comment">// 999　　</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。<br>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值就可以在f1外部读取它的内部变量了。<br>Js代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　n=<span class="number">999</span>;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(n);　　</div><div class="line">    &#125;</div><div class="line">　　<span class="keyword">return</span> f2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result=f1();</div><div class="line">result(); <span class="comment">// 999</span></div></pre></td></tr></table></figure>
<h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便<br>改变父函数内部变量的值。</p>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br>怎么来理解这句话呢？请看下面的代码。<br>Js代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    　　　alert(n);　　　　</div><div class="line">&#125;</div><div class="line">　　　　<span class="keyword">return</span> f2;</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">var</span> result=f1();</div><div class="line">　　result(); <span class="comment">// 999</span></div><div class="line">　　nAdd();</div><div class="line">　　result(); <span class="comment">// 1000</span></div></pre></td></tr></table></figure></p>
<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。<br>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。<br>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个<br>匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>理解JavaScript的闭包是迈向高级JS程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是闭包？&quot;&gt;&lt;a href=&quot;#什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包？&quot;&gt;&lt;/a&gt;什么是闭包？&lt;/h3&gt;&lt;p&gt;JavaScript的闭包是一个特色。官方解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常
    
    </summary>
    
    
      <category term="Javascript" scheme="http://huayan.site/tags/Javascript/"/>
    
      <category term="闭包" scheme="http://huayan.site/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.x 服务端渲染入门</title>
    <link href="http://huayan.site/2017/09/26/Vue%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/"/>
    <id>http://huayan.site/2017/09/26/Vue服务端渲染入门/</id>
    <published>2017-09-26T08:51:22.000Z</published>
    <updated>2017-09-26T08:41:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是服务端渲染-SSR"><a href="#什么是服务端渲染-SSR" class="headerlink" title="什么是服务端渲染 SSR"></a>什么是服务端渲染 SSR</h4><p>server side render<br>就是通过后端吐模板，而不是通过前端ajax获取数据，拼接字符串。</p>
<h4 id="为什么需要SSR"><a href="#为什么需要SSR" class="headerlink" title="为什么需要SSR"></a>为什么需要SSR</h4><p>需要SEO，因为爬虫不会等待ajax结果。<br>客户端网络慢，加载速度慢，影响用户体验。</p>
<h4 id="另一种解决办法-预渲染"><a href="#另一种解决办法-预渲染" class="headerlink" title="另一种解决办法 预渲染"></a>另一种解决办法 预渲染</h4><p>不是一次性下载整个单页应用，预渲染只是在构建时为了特定的路由生成特定的几个静态页面<br>你用<em>webpack</em>可以很简单地通过<em>prerender-spa-plugin</em>来添加预渲染</p>
<h4 id="NodeJS编写Vue的SSR"><a href="#NodeJS编写Vue的SSR" class="headerlink" title="NodeJS编写Vue的SSR"></a>NodeJS编写Vue的SSR</h4><p>首先<em>npm install –save-dev</em>的有 <em>vue express vue-server-renderer</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// server.js</span></div><div class="line"><span class="meta"></span></div><div class="line">'use strict';</div><div class="line"></div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line">global.Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> layout = fs.readFileSync(<span class="string">'./index.html'</span>, <span class="string">'utf8'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> renderer = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>).createRenderer()</div><div class="line"></div><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="keyword">var</span> server = express()</div><div class="line"></div><div class="line">server.use(<span class="string">'/assets'</span>,express.static(</div><div class="line">    path.resolve(__dirname,<span class="string">'assets'</span>)</div><div class="line">))</div><div class="line"></div><div class="line"></div><div class="line">server.get(<span class="string">'*'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 将Vue实例渲染成HTML</span></div><div class="line">    renderer.renderToString(</div><div class="line">        <span class="comment">// 创建一个应用实例</span></div><div class="line">        <span class="built_in">require</span>(<span class="string">'./assets/app'</span>)(),</div><div class="line"></div><div class="line">        <span class="comment">// 处理渲染结果</span></div><div class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">error, html</span>)</span>&#123;</div><div class="line">            <span class="keyword">if</span>(error)&#123;</div><div class="line">                <span class="built_in">console</span>.error(error);</div><div class="line">                <span class="keyword">return</span> res</div><div class="line">                    .status(<span class="number">500</span>)</div><div class="line">                    .send(<span class="string">'Server Error'</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 发送布局和HTML文件</span></div><div class="line">            res.send(layout.replace(<span class="string">'&lt;div id="app"&gt;&lt;/div&gt;'</span>, html))</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">server.listen(<span class="number">5000</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(error) <span class="keyword">throw</span> errorr;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Server is running at localhost:5000'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// index.html </div><div class="line"></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/assets/vue.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/assets/app.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript">app.$mount(<span class="string">'#app'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是服务端渲染-SSR&quot;&gt;&lt;a href=&quot;#什么是服务端渲染-SSR&quot; class=&quot;headerlink&quot; title=&quot;什么是服务端渲染 SSR&quot;&gt;&lt;/a&gt;什么是服务端渲染 SSR&lt;/h4&gt;&lt;p&gt;server side render&lt;br&gt;就是通过后端吐模
    
    </summary>
    
    
      <category term="服务端渲染" scheme="http://huayan.site/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
      <category term="SSR" scheme="http://huayan.site/tags/SSR/"/>
    
  </entry>
  
  <entry>
    <title>模拟Vue.js双向绑定的实现</title>
    <link href="http://huayan.site/2017/06/17/%E6%A8%A1%E6%8B%9FVue-js%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://huayan.site/2017/06/17/模拟Vue-js双向绑定的实现/</id>
    <published>2017-06-17T14:08:46.000Z</published>
    <updated>2017-06-17T14:27:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension" target="_blank" rel="external">原文地址</a><br> Vue.js 最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。本文仅探究双向绑定是怎样实现的。先讲涉及的知识点，再用简化得不能再简化的代码实现一个简单的 hello world 示例。</p>
<p>参考文章：<a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="external">https://segmentfault.com/a/1190000006599500</a></p>
<h3 id="一、访问器属性"><a href="#一、访问器属性" class="headerlink" title="一、访问器属性"></a>一、访问器属性</h3><p>访问器属性是对象中的一种特殊属性，它不能直接在对象中设置，而必须通过 defineProperty() 方法单独定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; &#125;;</div><div class="line"><span class="comment">// 为obj定义一个名为 hello 的访问器属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"hello"</span>, &#123;</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> sth&#125;,</div><div class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;<span class="comment">/* do sth */</span>&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>obj.hello // 可以像普通属性一样读取访问器属性</p>
<p>访问器属性的”值”比较特殊，读取或设置访问器属性的值，实际上是调用其内部特性：get和set函数。</p>
<p>obj.hello // 读取属性，就是调用get函数并返回get函数的返回值</p>
<p>obj.hello = “abc” // 为属性赋值，就是调用set函数，赋值其实是传参</p>
<p><img src="./1.png"></p>
<p>get 和 set 方法内部的 this 都指向 obj，这意味着 get 和 set 函数可以操作对象内部的值。另外，访问器属性的会”覆盖”同名的普通属性，因为访问器属性会被优先访问，与其同名的普通属性则会被忽略。</p>
<h3 id="二、极简双向绑定的实现"><a href="#二、极简双向绑定的实现" class="headerlink" title="二、极简双向绑定的实现"></a>二、极简双向绑定的实现</h3><p><img src="./2.png"></p>
<p>此例实现的效果是：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.hello 的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向绑定。</p>
<p><img src="./3.png"></p>
<p>以上就是 Vue 实现双向绑定的基本原理。</p>
<h3 id="三、分解任务"><a href="#三、分解任务" class="headerlink" title="三、分解任务"></a>三、分解任务</h3><p>上述示例仅仅是为了说明原理。我们最终要实现的是：</p>
<p><img src="./4.png"></p>
<p><img src="./5.png"></p>
<p> 首先将该任务分成几个子任务：</p>
<ol>
<li><p>输入框以及文本节点与 data 中的数据绑定</p>
</li>
<li><p>输入框内容变化时，data 中的数据同步变化。即 view =&gt; model 的变化。</p>
</li>
<li><p>data 中的数据变化时，文本节点的内容同步变化。即 model =&gt; view 的变化。</p>
</li>
</ol>
<p>要实现任务一，需要对 DOM 进行编译，这里有一个知识点：DocumentFragment。</p>
<h3 id="四、DocumentFragment"><a href="#四、DocumentFragment" class="headerlink" title="四、DocumentFragment"></a>四、DocumentFragment</h3><p>DocumentFragment（文档片段）可以看作节点容器，它可以包含多个子节点，当我们将它插入到 DOM 中时，只有它的子节点会插入目标节点，所以把它看作一组节点的容器。使用 DocumentFragment 处理节点，速度和性能远远优于直接操作 DOM。Vue 进行编译时，就是将挂载目标的所有子节点劫持（真的是劫持，通过 append 方法，DOM 中的节点会被自动删除）到 DocumentFragment 中，经过一番处理后，再将 DocumentFragment 整体返回插入挂载目标。</p>
<p><img src="./6.png"></p>
<p>#勘误：flag.append() 应为 flag.appendChild()。下同。在 Chrome 中用 append() 竟然正常，没报错。</p>
<p><img src="./7.png"></p>
<h3 id="五、数据初始化绑定"><a href="#五、数据初始化绑定" class="headerlink" title="五、数据初始化绑定"></a>五、数据初始化绑定</h3><p><img src="./8.png"></p>
<p><img src="./9.png"></p>
<p><img src="./10.png"></p>
<p>以上代码实现了任务一，我们可以看到，hello world已经呈现在输入框和文本节点中。</p>
<p><img src="./11.png"></p>
<h3 id="六、响应式的数据绑定"><a href="#六、响应式的数据绑定" class="headerlink" title="六、响应式的数据绑定"></a>六、响应式的数据绑定</h3><p>再来看任务二的实现思路：当我们在输入框输入数据的时候，首先触发 input 事件（或者 keyup、change 事件），在相应的事件处理程序中，我们获取输入框的 value 并赋值给 vm 实例的 text 属性。我们会利用 defineProperty 将 data 中的 text 设置为 vm 的访问器属性，因此给 vm.text 赋值，就会触发 set 方法。在 set 方法中主要做两件事，第一是更新属性的值，第二留到任务三再说。</p>
<p><img src="./12.png"></p>
<p><img src="./13.png"></p>
<p>任务二也就完成了，text 属性值会与输入框的内容同步变化：</p>
<p><img src="./14.png"></p>
<h3 id="七、订阅-发布模式（subscribe-amp-publish）"><a href="#七、订阅-发布模式（subscribe-amp-publish）" class="headerlink" title="七、订阅/发布模式（subscribe&amp;publish）"></a>七、订阅/发布模式（subscribe&amp;publish）</h3><p>text 属性变化了，set 方法触发了，但是文本节点的内容没有变化。如何让同样绑定到 text 的文本节点也同步变化呢？这里又有一个知识点：订阅发布模式。</p>
<p>订阅发布模式（又称观察者模式）定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象。</p>
<p>发布者发出通知 =&gt; 主题对象收到通知并推送给订阅者 =&gt; 订阅者执行相应操作</p>
<p><img src="./15.png"></p>
<p>之前提到的，当 set 方法触发后做的第二件事就是作为发布者发出通知：“我是属性 text，我变了”。文本节点则是作为订阅者，在收到消息后执行相应的更新操作。</p>
<h3 id="八、双向绑定的实现"><a href="#八、双向绑定的实现" class="headerlink" title="八、双向绑定的实现"></a>八、双向绑定的实现</h3><p>回顾一下，每当 new 一个 Vue，主要做了两件事：第一个是监听数据：observe(data)，第二个是编译 HTML：nodeToFragement(id)。</p>
<p>在监听数据的过程中，会为 data 中的每一个属性生成一个主题对象 dep。</p>
<p>在编译 HTML 的过程中，会为每个与数据绑定相关的节点生成一个订阅者 watcher，watcher 会将自己添加到相应属性的 dep 中。</p>
<p>我们已经实现：修改输入框内容 =&gt; 在事件回调函数中修改属性值 =&gt; 触发属性的 set 方法。</p>
<p>接下来我们要实现的是：发出通知 dep.notify() =&gt; 触发订阅者的 update 方法 =&gt; 更新视图。</p>
<p>这里的关键逻辑是：如何将 watcher 添加到关联属性的 dep 中。</p>
<p><img src="./16.png"></p>
<p>在编译 HTML 过程中，为每个与 data 关联的节点生成一个 Watcher。Watcher 函数中发生了什么呢？</p>
<p><img src="./17.png"></p>
<p>首先，将自己赋给了一个全局变量 Dep.target；</p>
<p>其次，执行了 update 方法，进而执行了 get 方法，get 的方法读取了 vm 的访问器属性，从而触发了访问器属性的 get 方法，get 方法中将该 watcher 添加到了对应访问器属性的 dep 中；</p>
<p>再次，获取属性的值，然后更新视图。</p>
<p>最后，将 Dep.target 设为空。因为它是全局变量，也是 watcher 与 dep 关联的唯一桥梁，任何时刻都必须保证 Dep.target 只有一个值。</p>
<p><img src="./18.png"></p>
<p><img src="./19.png"></p>
<p>至此，hello world 双向绑定就基本实现了。文本内容会随输入框内容同步变化，在控制器中修改 vm.text 的值，会同步反映到文本内容中。</p>
<p>完整代码：<a href="https://github.com/bison1994/two-way-data-binding" target="_blank" rel="external">https://github.com/bison1994/two-way-data-binding</a></p>
<p>更详尽的源码分析，可以参考滴滴的这篇文章：<a href="https://github.com/DDFE/DDFE-blog/issues/7" target="_blank" rel="external">https://github.com/DDFE/DDFE-blog/issues/7</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt; Vue.
    
    </summary>
    
    
      <category term="javascript" scheme="http://huayan.site/tags/javascript/"/>
    
      <category term="双向绑定" scheme="http://huayan.site/tags/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    
      <category term="Vue" scheme="http://huayan.site/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>神秘的属性描述符</title>
    <link href="http://huayan.site/2017/06/16/%E7%A5%9E%E7%A7%98%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <id>http://huayan.site/2017/06/16/神秘的属性描述符/</id>
    <published>2017-06-16T01:59:52.000Z</published>
    <updated>2017-06-16T03:17:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/xiaohuochai/p/5743821.html" target="_blank" rel="external">http://www.cnblogs.com/xiaohuochai/p/5743821.html</a></p>
<h3 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h3><p>对于操作系统中的文件，我们可以驾轻就熟将其设置为只读、隐藏、系统文件或普通文件。于对象来说，属性描述符提供类似的功能，用来描述对象的值、是否可配置、是否可修改以及是否可枚举。本文就来介绍对象中神秘的属性描述符</p>
<h4 id="描述符类型"><a href="#描述符类型" class="headerlink" title="描述符类型"></a>描述符类型</h4><p>　　对象属性描述符的类型分为两种：数据属性和访问器属性</p>
<h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>数据属性(data property)包含一个数据值的位置，在这个位置可以读取和写入值。数据属性有4个特性</p>
<ol>
<li>Configurable(可配置性)</li>
</ol>
<p>　　可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true</p>
<ol>
<li>Enumerable(可枚举性)</li>
</ol>
<p>　　可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true</p>
<ol>
<li>Writable(可写性)</li>
</ol>
<p>　　可写性决定是否可以修改属性的值，默认值为true</p>
<ol>
<li>Value(属性值)</li>
</ol>
<p>属性值包含这个属性的数据值，读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为undefined</p>
<h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>对象属性是名字、值和一组属性描述符构成的。而属性值可以用一个或两个方法替代，这两个方法就是getter和setter。而这种属性类型叫访问器属性(accessor property)</p>
<ol>
<li>Configurable(可配置性)</li>
</ol>
<p>　　可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true</p>
<ol>
<li>Enumerable(可枚举性)</li>
</ol>
<p>　　可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true</p>
<ol>
<li>getter</li>
</ol>
<p>　　在读取属性时调用的函数。默认值为undefined</p>
<ol>
<li>setter</li>
</ol>
<p>　　在写入属性时调用的函数。默认值为undefined</p>
<p>　　和数据属性不同，访问器属性不具有可写性(Writable)。如果属性同时具有getter和setter方法，那么它是一个读/写属性。如果它只有getter方法，那么它是一个只读属性。如果它只有setter方法，那么它是一个只写属性。读取只写属性总是返回undefined</p>
<h4 id="描述符方法"><a href="#描述符方法" class="headerlink" title="描述符方法"></a>描述符方法</h4><p>　　前面介绍了属性描述符，要想设置它们，就需要用到描述符方法。描述符方法总共有以下4个：</p>
<ol>
<li>Object.getOwnPropertyDescriptor()</li>
</ol>
<p>　　Object.getOwnPropertyDescriptor(o,name)方法用于查询一个属性的描述符，并以对象的形式返回</p>
<p>　　查询obj.a属性时，可配置性、可枚举性、可写性都是默认的true，而value是a的属性值1</p>
<p>　　查询obj.b属性时，因为obj.b属性不存在，该方法返回undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="comment">//Object &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">'a'</span>));</div><div class="line"><span class="comment">//undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">'b'</span>));</div></pre></td></tr></table></figure>
<ol>
<li>Object.defineProperty()</li>
</ol>
<p>　　Object.defineProperty(o,name,desc)方法用于创建或配置对象的一个属性的描述符，返回配置后的对象</p>
<p>　　使用该方法创建或配置对象属性的描述符时，如果不针对该属性进行描述符的配置，则该项描述符默认为false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="comment">//&#123;a:1&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.defineProperty(obj,<span class="string">'a'</span>,&#123;</div><div class="line">        <span class="attr">value</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">writable</span>: <span class="literal">true</span></div><div class="line">    &#125;));</div><div class="line"></div><div class="line"><span class="comment">//由于没有配置enumerable和configurable，所以它们的值为false</span></div><div class="line"><span class="comment">//&#123;value: 1, writable: true, enumerable: false, configurable: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">'a'</span>));</div></pre></td></tr></table></figure>
<ol>
<li>Object.defineProperties()</li>
</ol>
<p>　　Object.defineProperty(o,descriptors)方法用于创建或配置对象的多个属性的描述符，返回配置后的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>:<span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//&#123;a: 1, b: 2&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.defineProperties(obj,&#123;</div><div class="line">        <span class="attr">a</span>:&#123;<span class="attr">writable</span>:<span class="literal">false</span>&#125;,</div><div class="line">        <span class="attr">b</span>:&#123;<span class="attr">value</span>:<span class="number">2</span>&#125;</div><div class="line">    &#125;));</div><div class="line"></div><div class="line"><span class="comment">//&#123;value: 1, writable: false, enumerable: true, configurable: true&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">'a'</span>));</div><div class="line"><span class="comment">//&#123;value: 2, writable: false, enumerable: false, configurable: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">'b'</span>));</div></pre></td></tr></table></figure>
<ol>
<li>Object.create()</li>
</ol>
<p>　　Object.create(proto,descriptors)方法使用指定的原型和属性来创建一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,&#123;</div><div class="line">    <span class="attr">a</span>:&#123;<span class="attr">writable</span>: <span class="literal">false</span>,<span class="attr">value</span>:<span class="number">1</span>,<span class="attr">enumerable</span>:<span class="literal">true</span>&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//&#123;value: 1, writable: false, enumerable: true, configurable: true&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">'a'</span>));</div></pre></td></tr></table></figure>
<h4 id="描述符详述"><a href="#描述符详述" class="headerlink" title="描述符详述"></a>描述符详述</h4><p>　　前面分别介绍了数据属性和访问器属性的描述符，但没有详细说明其含义及使用，接下来逐一进行说明</p>
<h5 id="可写性-writable"><a href="#可写性-writable" class="headerlink" title="可写性(writable)"></a>可写性(writable)</h5><p>可写性决定是否可以修改属性的值，默认值为true<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line">o.a = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div><div class="line">　　设置writable:<span class="literal">false</span>后，赋值语句会静默失效</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">writable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//1</span></div><div class="line"><span class="comment">//由于设置了writable为false，所以o.a=2这个语句会静默失效</span></div><div class="line">o.a = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//1</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//由于writable设置为true，所以o.a可以被修改为2</span></div><div class="line">o.a = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>在严格模式下通过赋值语句为writable为false的属性赋值，会提示类型错误TypeError</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">writable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//Uncaught TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'</span></div><div class="line">o.a = <span class="number">2</span>;</div></pre></td></tr></table></figure>
<p>　　[注意]设置writable:false后，通过Object.defineProperty()方法改变属性value的值不会受影响，因为这也意味着在重置writable的属性值为false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">writable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//1</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">value</span>:<span class="number">2</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<h5 id="可配置性-Configurable"><a href="#可配置性-Configurable" class="headerlink" title="可配置性(Configurable)"></a>可配置性(Configurable)</h5><p>　　可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true</p>
<ol>
<li>设置Configurable:false后，无法使用delete删除属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"><span class="keyword">delete</span> o.a;<span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//1</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>　　在严格模式下删除为configurable为false的属性，会提示类型错误TypeError</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//Uncaught TypeError: Cannot delete property 'a' of #&lt;Object&gt;</span></div><div class="line"><span class="keyword">delete</span> o.a;</div></pre></td></tr></table></figure>
<p>　　[注意]使用var命令声明变量时，变量的configurable为false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="comment">//&#123;value: 1, writable: true, enumerable: true, configurable: false&#125;</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="keyword">this</span>,<span class="string">'a'</span>);</div></pre></td></tr></table></figure>
<ol>
<li>一般地，设置Configurable:false后，将无法再使用defineProperty()方法来修改属性描述符</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//Uncaught TypeError: Cannot redefine property: a</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">true</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>　　有一个例外，设置Configurable:false后，只允许writable的状态从true变为false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">configurable</span>:<span class="literal">false</span>,</div><div class="line">    <span class="attr">writable</span>:<span class="literal">true</span></div><div class="line">&#125;);</div><div class="line">o.a = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">writable</span>:<span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//由于writable:false生效，对象a的o属性无法修改值，所以o.a=3的赋值语句静默失败</span></div><div class="line">o.a = <span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<h5 id="可枚举性-Enumerable"><a href="#可枚举性-Enumerable" class="headerlink" title="可枚举性(Enumerable)"></a>可枚举性(Enumerable)</h5><p>　　可枚举性决定属性是否出现在对象的属性枚举中，具体来说，for-in循环、Object.keys方法、JSON.stringify方法是否会取到该属性</p>
<p>　　用户定义的普通属性默认是可枚举的，而原生继承的属性默认是不可枚举的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//由于原生继承的属性默认不可枚举，所以只取得自定义的属性a:1</span></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o)&#123;</div><div class="line">    <span class="built_in">console</span>.log(o[i]);<span class="comment">//1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//由于enumerable被设置为false，在for-in循环中a属性无法被枚举出来</span></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;<span class="attr">enumerable</span>:<span class="literal">false</span>&#125;);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o)&#123;</div><div class="line">    <span class="built_in">console</span>.log(o[i]);<span class="comment">//undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>propertyIsEnumerable()</p>
<p>　　propertyIsEnumerable()方法用于判断对象的属性是否可枚举<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">'a'</span>));<span class="comment">//true</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;<span class="attr">enumerable</span>:<span class="literal">false</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">'a'</span>));<span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h5 id="get和set"><a href="#get和set" class="headerlink" title="get和set"></a>get和set</h5><p>　　get是一个隐藏函数，在获取属性值时调用。set也是一个隐藏函数，在设置属性值时调用，它们的默认值都是undefined。Object.definedProperty()中的get和set对应于对象字面量中get和set方法</p>
<p>　　[注意]getter和setter取代了数据属性中的value和writable属性</p>
<ol>
<li>给只设置get方法，没有设置set方法的对象赋值会静默失败，在严格模式下会报错</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    get a()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;    </div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div><div class="line"><span class="comment">//由于没有设置set方法，所以o.a=3的赋值语句会静默失败</span></div><div class="line">o.a = <span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div><div class="line"><span class="comment">//由于没有设置set方法，所以o.a=3的赋值语句会静默失败</span></div><div class="line">o.a = <span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>　　在严格模式下，给没有设置set方法的访问器属性赋值会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    get a()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;    </div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div><div class="line"><span class="comment">//由于没有设置set方法，所以o.a=3的赋值语句会报错</span></div><div class="line"><span class="comment">//Uncaught TypeError: Cannot set property a of #&lt;Object&gt; which has only a getter</span></div><div class="line">o.a = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div><div class="line"><span class="comment">//由于没有设置set方法，所以o.a=3的赋值语句会报错</span></div><div class="line"><span class="comment">//Uncaught TypeError: Cannot set property a of #&lt;Object&gt; which has only a getter</span></div><div class="line">o.a = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<ol>
<li>只设置set方法，而不设置get方法，则对象属性值为undefined</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    set a(val)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;    </div><div class="line">o.a = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">o.a = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<ol>
<li>一般地，set和get方法是成对出现的</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o =&#123;</div><div class="line">    get a()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a;</div><div class="line">    &#125;,</div><div class="line">    set a(val)&#123;</div><div class="line">        <span class="keyword">this</span>._a = val*<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">o.a = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'a'</span>,&#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">set</span> :<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>._a = val*<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">o.a = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<h4 id="对象状态"><a href="#对象状态" class="headerlink" title="对象状态"></a>对象状态</h4><p>属性描述符只能用来控制对象中一个属性的状态。而如果要控制对象的状态，就要用到下面的6种方法 </p>
<h5 id="Object-preventExtensions-禁止扩展"><a href="#Object-preventExtensions-禁止扩展" class="headerlink" title="Object.preventExtensions()(禁止扩展)"></a>Object.preventExtensions()(禁止扩展)</h5><p>　　Object.preventExtensions()方法使一个对象无法再添加新的属性，并返回当前对象</p>
<h5 id="Object-isExtensible-测试扩展"><a href="#Object-isExtensible-测试扩展" class="headerlink" title="Object.isExtensible()(测试扩展)"></a>Object.isExtensible()(测试扩展)</h5><p>　　Object.isExtensible()方法用来检测该对象是否可以扩展</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(o));<span class="comment">//true</span></div><div class="line">o.b = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(o);<span class="comment">//&#123;a: 1, b: 2&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.preventExtensions(o));<span class="comment">//&#123;a: 1, b: 2&#125;</span></div><div class="line"><span class="comment">//由于对象o禁止扩展，所以该赋值语句静默失败</span></div><div class="line">o.c = <span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(o));<span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(o);<span class="comment">//&#123;a: 1, b: 2&#125;</span></div></pre></td></tr></table></figure>
<p>　　在严格模式下，给禁止扩展的对象添加属性会报TypeError错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.preventExtensions(o));<span class="comment">//&#123;a:1&#125;</span></div><div class="line"><span class="comment">//Uncaught TypeError: Can't add property c, object is not extensible</span></div><div class="line">o.c = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<p>　　Object.preventExtensions()方法并不改变对象中属性的描述符状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="comment">//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">'a'</span>));</div><div class="line"><span class="built_in">Object</span>.preventExtensions(o);</div><div class="line"><span class="comment">//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">'a'</span>));</div></pre></td></tr></table></figure>
<h5 id="Object-seal-对象封印"><a href="#Object-seal-对象封印" class="headerlink" title="Object.seal()(对象封印)"></a>Object.seal()(对象封印)</h5><p>　　对象封印又叫对象密封，使一个对象不可扩展并且所有属性不可配置，并返回当前对象</p>
<h5 id="Object-isSealed-测试封印"><a href="#Object-isSealed-测试封印" class="headerlink" title="Object.isSealed()(测试封印)"></a>Object.isSealed()(测试封印)</h5><p>　　Object.isSealed()方法用来检测该方法是否被封印</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(o));<span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.seal(o));<span class="comment">//&#123;a:1,b:2&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(o));<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> o.b);<span class="comment">//false</span></div><div class="line">o.c = <span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(o);<span class="comment">//&#123;a:1,b:2&#125;</span></div></pre></td></tr></table></figure>
<p>　　在严格模式下，删除旧属性或添加新属性都会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.seal(o));<span class="comment">//&#123;a:1,b:2&#125;</span></div><div class="line"><span class="comment">//Uncaught TypeError: Cannot delete property 'b' of #&lt;Object&gt;</span></div><div class="line"><span class="keyword">delete</span> o.b;</div></pre></td></tr></table></figure>
<p>　　这个方法实际上会在现有对象上调用Object.preventExtensions()方法，并把所有现有属性的configurable描述符置为false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</div><div class="line"><span class="comment">//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">'a'</span>));</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.seal(o));<span class="comment">//&#123;a:1,b:2&#125;</span></div><div class="line"><span class="comment">//&#123;value: 1, writable: true, enumerable: true, configurable: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">'a'</span>));</div></pre></td></tr></table></figure>
<h5 id="Object-freeze-对象冻结"><a href="#Object-freeze-对象冻结" class="headerlink" title="Object.freeze()(对象冻结)"></a>Object.freeze()(对象冻结)</h5><p>　　Object.freeze()方法使一个对象不可扩展，不可配置，也不可改写，变成一个仅可以枚举的只读常量，并返回当前对象</p>
<h5 id="Object-isFrozen-检测冻结"><a href="#Object-isFrozen-检测冻结" class="headerlink" title="Object.isFrozen()(检测冻结)"></a>Object.isFrozen()(检测冻结)</h5><p>　　Object.isFrozen()方法用来检测一个对象是否被冻结</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(o));<span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.freeze(o));<span class="comment">//&#123;a:1,b:2&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(o));<span class="comment">//true</span></div><div class="line">o.a = <span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(o);<span class="comment">//&#123;a:1,b:2&#125;</span></div></pre></td></tr></table></figure>
<p>　　在严格模式下，删除旧属性、添加新属性、更改现有属性都会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.freeze(o));<span class="comment">//&#123;a:1,b:2&#125;</span></div><div class="line"><span class="comment">//Uncaught TypeError: Cannot assign to read only property 'a' of object '#&lt;Object&gt;'</span></div><div class="line">o.a = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<p>　　这个方法实际上会在现有对象上调用Object.seal()方法，并把所有现有属性的writable描述符置为false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line"><span class="comment">//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">'a'</span>));</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.freeze(o));<span class="comment">//&#123;a:1&#125;</span></div><div class="line"><span class="comment">//&#123;value: 1, writable: false, enumerable: true, configurable: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">'a'</span>));</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5743821.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/xiaohuochai/p/5743821.h
    
    </summary>
    
    
      <category term="双向绑定" scheme="http://huayan.site/tags/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    
      <category term="属性访问器" scheme="http://huayan.site/tags/%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Javascript角度理解发布订阅者模式</title>
    <link href="http://huayan.site/2017/06/14/Javascript%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://huayan.site/2017/06/14/Javascript角度理解发布订阅者模式/</id>
    <published>2017-06-14T08:51:22.000Z</published>
    <updated>2017-06-15T03:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/tugenhua0707/p/4687947.html" target="_blank" rel="external">原文地址</a></p>
<h3 id="发布订阅模式介绍"><a href="#发布订阅模式介绍" class="headerlink" title="发布订阅模式介绍"></a>发布订阅模式介绍</h3><blockquote>
<p>发布订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p>
</blockquote>
<h4 id="现实生活中的发布-订阅模式；"><a href="#现实生活中的发布-订阅模式；" class="headerlink" title="现实生活中的发布-订阅模式；"></a>现实生活中的发布-订阅模式；</h4><p>比如小红最近在淘宝网上看上一双鞋子，但是呢 联系到卖家后，才发现这双鞋卖光了，但是小红对这双鞋又非常喜欢，所以呢联系卖家，问卖家什么时候有货，卖家告诉她，要等一个星期后才有货，卖家告诉小红，要是你喜欢的话，你可以收藏我们的店铺，等有货的时候再通知你，所以小红收藏了此店铺，但与此同时，小明，小花等也喜欢这双鞋，也收藏了该店铺；等来货的时候就依次会通知他们；</p>
<p>在上面的故事中，可以看出是一个典型的发布订阅模式，卖家是属于发布者，小红，小明等属于订阅者，订阅该店铺，卖家作为发布者，当鞋子到了的时候，会依次通知小明，小红等，依次使用旺旺等工具给他们发布消息；</p>
<h4 id="发布订阅模式的优点："><a href="#发布订阅模式的优点：" class="headerlink" title="发布订阅模式的优点："></a>发布订阅模式的优点：</h4><ol>
<li><p>支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。<br>比如上面的列子，小明，小红不需要天天逛淘宝网看鞋子到了没有，在合适的时间点，发布者(卖家)来货了的时候，会通知该订阅者(小红，小明等人)。</p>
</li>
<li><p>发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变；同理卖家（发布者）它只需要将鞋子来货的这件事告诉订阅者(买家)，他不管买家到底买还是不买，还是买其他卖家的。只要鞋子到货了就通知订阅者即可。</p>
</li>
</ol>
<p>对于第一点，我们日常工作中也经常使用到，比如我们的ajax请求，请求有成功(success)和失败(error)的回调函数，我们可以订阅ajax的success和error事件。我们并不关心对象在异步运行的状态，我们只关心success的时候或者error的时候我们要做点我们自己的事情就可以了~</p>
<h4 id="发布订阅模式的缺点："><a href="#发布订阅模式的缺点：" class="headerlink" title="发布订阅模式的缺点："></a>发布订阅模式的缺点：</h4><ul>
<li>创建订阅者需要消耗一定的时间和内存。</li>
<li>虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等</li>
</ul>
<h3 id="如何实现发布–订阅模式？"><a href="#如何实现发布–订阅模式？" class="headerlink" title="如何实现发布–订阅模式？"></a>如何实现发布–订阅模式？</h3><ol>
<li>首先要想好谁是发布者(比如上面的卖家)。</li>
<li>然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。</li>
<li>最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。</li>
</ol>
<p>我们还可以在回调函数里面添加一点参数，比如鞋子的颜色，鞋子尺码等信息；</p>
<p>我们先来实现下简单的发布-订阅模式；代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shoeObj = &#123;&#125;; <span class="comment">// 定义发布者</span></div><div class="line">shoeObj.list = []; <span class="comment">// 缓存列表 存放订阅者回调函数</span></div><div class="line">        </div><div class="line"><span class="comment">// 增加订阅者</span></div><div class="line">shoeObj.listen = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    shoeObj.list.push(fn);  <span class="comment">// 订阅消息添加到缓存列表</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 发布消息</span></div><div class="line">shoeObj.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = <span class="keyword">this</span>.list[i++];) &#123;</div><div class="line">        fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 小红订阅如下消息</span></div><div class="line">shoeObj.listen(<span class="function"><span class="keyword">function</span>(<span class="params">color,size</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"颜色是："</span>+color);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"尺码是："</span>+size);  </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 小花订阅如下消息</span></div><div class="line">shoeObj.listen(<span class="function"><span class="keyword">function</span>(<span class="params">color,size</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"再次打印颜色是："</span>+color);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"再次打印尺码是："</span>+size); </div><div class="line">&#125;);</div><div class="line">shoeObj.trigger(<span class="string">"红色"</span>,<span class="number">40</span>);</div><div class="line">shoeObj.trigger(<span class="string">"黑色"</span>,<span class="number">42</span>);</div></pre></td></tr></table></figure></p>
<p><img src="./01.png"><br>打印如上截图，我们看到订阅者接收到发布者的每个消息，但是呢，对于小红来说，她只想接收颜色为红色的消息，不想接收颜色为黑色的消息，为此我们需要对代码进行如下改造下，我们可以先增加一个key，使订阅者只订阅自己感兴趣的消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shoeObj = &#123;&#125;; <span class="comment">// 定义发布者</span></div><div class="line">shoeObj.list = []; <span class="comment">// 缓存列表 存放订阅者回调函数</span></div><div class="line">        </div><div class="line"><span class="comment">// 增加订阅者</span></div><div class="line">shoeObj.listen = <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.list[key]) &#123;</div><div class="line">        <span class="comment">// 如果还没有订阅过此类消息，给该类消息创建一个缓存列表</span></div><div class="line">        <span class="keyword">this</span>.list[key] = []; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.list[key].push(fn);  <span class="comment">// 订阅消息添加到缓存列表</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 发布消息</span></div><div class="line">shoeObj.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>); <span class="comment">// 取出消息类型名称</span></div><div class="line">    <span class="keyword">var</span> fns = <span class="keyword">this</span>.list[key];  <span class="comment">// 取出该消息对应的回调函数的集合</span></div><div class="line"></div><div class="line">    <span class="comment">// 如果没有订阅过该消息的话，则返回</span></div><div class="line">    <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = fns[i++]; ) &#123;</div><div class="line">        fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">// arguments 是发布消息时附送的参数</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 小红订阅如下消息</span></div><div class="line">shoeObj.listen(<span class="string">'red'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"尺码是："</span>+size);  </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 小花订阅如下消息</span></div><div class="line">shoeObj.listen(<span class="string">'block'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"再次打印尺码是："</span>+size); </div><div class="line">&#125;);</div><div class="line">shoeObj.trigger(<span class="string">"red"</span>,<span class="number">40</span>);</div><div class="line">shoeObj.trigger(<span class="string">"block"</span>,<span class="number">42</span>);</div></pre></td></tr></table></figure>
<p>上面的代码，我们再来运行打印下 如下：<br><img src="./02.png"><br>可以看到，订阅者只订阅自己感兴趣的消息了；</p>
<h3 id="发布—订阅模式的代码封装"><a href="#发布—订阅模式的代码封装" class="headerlink" title="发布—订阅模式的代码封装"></a>发布—订阅模式的代码封装</h3><p>我们知道，对于上面的代码，小红去买鞋这么一个对象shoeObj 进行订阅，但是如果以后我们需要对买房子或者其他的对象进行订阅呢，我们需要复制上面的代码，再重新改下里面的对象代码；为此我们需要进行代码封装；</p>
<p>如下代码封装：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> event = &#123;</div><div class="line">    <span class="attr">list</span>: [],</div><div class="line">    <span class="attr">listen</span>: <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.list[key]) &#123;</div><div class="line">            <span class="keyword">this</span>.list[key] = [];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 订阅的消息添加到缓存列表中</span></div><div class="line">        <span class="keyword">this</span>.list[key].push(fn);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">trigger</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">var</span> fns = <span class="keyword">this</span>.list[key];</div><div class="line">        <span class="comment">// 如果没有订阅过该消息的话，则返回</span></div><div class="line">        <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = fns[i++];) &#123;</div><div class="line">            fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们在定义一个initEvent函数，这个函数使所有的普通对象都具有发布订阅功能，如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> initEvent = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> event) &#123;</div><div class="line">        obj[i] = event[i];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 我们再来测试下，我们还是给shoeObj这个对象添加发布-订阅功能；</span></div><div class="line"><span class="keyword">var</span> shoeObj = &#123;&#125;;</div><div class="line">initEvent(shoeObj);</div><div class="line"></div><div class="line"><span class="comment">// 小红订阅如下消息</span></div><div class="line">shoeObj.listen(<span class="string">'red'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"尺码是："</span>+size);  </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 小花订阅如下消息</span></div><div class="line">shoeObj.listen(<span class="string">'block'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"再次打印尺码是："</span>+size); </div><div class="line">&#125;);</div><div class="line">shoeObj.trigger(<span class="string">"red"</span>,<span class="number">40</span>);</div><div class="line">shoeObj.trigger(<span class="string">"block"</span>,<span class="number">42</span>);</div></pre></td></tr></table></figure>
<h3 id="如何取消订阅事件？"><a href="#如何取消订阅事件？" class="headerlink" title="如何取消订阅事件？"></a>如何取消订阅事件？</h3><p>比如上面的列子，小红她突然不想买鞋子了，那么对于卖家的店铺他不想再接受该店铺的消息，那么小红可以取消该店铺的订阅。</p>
<p>如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">event.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> fns = <span class="keyword">this</span>.list[key];</div><div class="line">    <span class="comment">// 如果key对应的消息没有订阅过的话，则返回</span></div><div class="line">    <span class="keyword">if</span>(!fns) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅</span></div><div class="line">    <span class="keyword">if</span>(!fn) &#123;</div><div class="line">        fn &amp;&amp; (fns.length = <span class="number">0</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = fns.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">var</span> _fn = fns[i];</div><div class="line">            <span class="keyword">if</span>(_fn === fn) &#123;</div><div class="line">                fns.splice(i,<span class="number">1</span>); <span class="comment">// 删除订阅者的回调函数</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>测试代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> initEvent = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> event) &#123;</div><div class="line">        obj[i] = event[i];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> shoeObj = &#123;&#125;;</div><div class="line">initEvent(shoeObj);</div><div class="line"></div><div class="line"><span class="comment">// 小红订阅如下消息</span></div><div class="line">shoeObj.listen(<span class="string">'red'</span>,fn1 = <span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"尺码是："</span>+size);  </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 小花订阅如下消息</span></div><div class="line">shoeObj.listen(<span class="string">'red'</span>,fn2 = <span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"再次打印尺码是："</span>+size); </div><div class="line">&#125;);</div><div class="line">shoeObj.remove(<span class="string">"red"</span>,fn1);</div><div class="line">shoeObj.trigger(<span class="string">"red"</span>,<span class="number">42</span>);</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="./03.png"></p>
<h3 id="全局–发布订阅对象代码封装"><a href="#全局–发布订阅对象代码封装" class="headerlink" title="全局–发布订阅对象代码封装"></a>全局–发布订阅对象代码封装</h3><p>我们再来看看我们传统的ajax请求吧，比如我们传统的ajax请求，请求成功后需要做如下事情：</p>
<ol>
<li>渲染数据。</li>
<li>使用数据来做一个动画。</li>
</ol>
<p>那么我们以前肯定是如下写代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$.ajax(“http:<span class="comment">//127.0.0.1/index.php”,function(data)&#123;</span></div><div class="line">    rendedData(data);  <span class="comment">// 渲染数据</span></div><div class="line">    doAnimate(data);  <span class="comment">// 实现动画 </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>假如以后还需要做点事情的话，我们还需要在里面写调用的方法；这样代码就耦合性很高，那么我们现在使用发布-订阅模式来看如何重构上面的业务需求代码；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$.ajax(“http:<span class="comment">//127.0.0.1/index.php”,function(data)&#123;</span></div><div class="line">    Obj.trigger(‘success’,data);  <span class="comment">// 发布请求成功后的消息</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 下面我们来订阅此消息，比如我现在订阅渲染数据这个消息；</span></div><div class="line">Obj.listen(“success”,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">   renderData(data);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 订阅动画这个消息</span></div><div class="line">Obj.listen(“success”,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">   doAnimate(data); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为此我们可以封装一个全局发布-订阅模式对象；如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Event = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> list = &#123;&#125;,</div><div class="line">          listen,</div><div class="line">          trigger,</div><div class="line">          remove;</div><div class="line">          listen = <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</div><div class="line">            <span class="keyword">if</span>(!list[key]) &#123;</div><div class="line">                list[key] = [];</div><div class="line">            &#125;</div><div class="line">            list[key].push(fn);</div><div class="line">        &#125;;</div><div class="line">        trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>),</div><div class="line">                 fns = list[key];</div><div class="line">            <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[i++];) &#123;</div><div class="line">                fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        remove = <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> fns = list[key];</div><div class="line">            <span class="keyword">if</span>(!fns) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!fn) &#123;</div><div class="line">                fns &amp;&amp; (fns.length = <span class="number">0</span>);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = fns.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</div><div class="line">                    <span class="keyword">var</span> _fn = fns[i];</div><div class="line">                    <span class="keyword">if</span>(_fn === fn) &#123;</div><div class="line">                        fns.splice(i,<span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">listen</span>: listen,</div><div class="line">            <span class="attr">trigger</span>: trigger,</div><div class="line">            <span class="attr">remove</span>: remove</div><div class="line">        &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// 测试代码如下：</span></div><div class="line">Event.listen(<span class="string">"color"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">size</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"尺码为:"</span>+size); <span class="comment">// 打印出尺码为42</span></div><div class="line">&#125;);</div><div class="line">Event.trigger(<span class="string">"color"</span>,<span class="number">42</span>);</div></pre></td></tr></table></figure></p>
<h3 id="理解模块间通信"><a href="#理解模块间通信" class="headerlink" title="理解模块间通信"></a>理解模块间通信</h3><p>我们使用上面封装的全局的发布-订阅对象来实现两个模块之间的通信问题；比如现在有一个页面有一个按钮，每次点击此按钮后，div中会显示此按钮被点击的总次数；如下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"count"</span>&gt;</span>点将我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"showcount"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们中的a.js 负责处理点击操作 及 发布消息；如下JS代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"count"</span>);</div><div class="line">    button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        Event.trigger(<span class="string">"add"</span>,count++);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>b.js 负责监听add这个消息，并把点击的总次数显示到页面上来；如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"showcount"</span>);</div><div class="line">    Event.listen(<span class="string">'add'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">        div.innerHTML = count;</div><div class="line">    &#125;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>下面是html代码如下，JS应用如下引用即可：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"global.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"count"</span>&gt;</span>点将我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"showcount"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">"a.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">"b.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如上代码，当点击一次按钮后，showcount的div会自动加1，如上演示的是2个模块之间如何使用发布-订阅模式之间的通信问题；</p>
<p>其中global.js 就是我们上面封装的全局-发布订阅模式对象的封装代码；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/tugenhua0707/p/4687947.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;发布订阅模式介绍&quot;&gt;&lt;a href=&quot;#发布订阅
    
    </summary>
    
    
      <category term="设计模式" scheme="http://huayan.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入之从原型到原型链</title>
    <link href="http://huayan.site/2017/05/21/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://huayan.site/2017/05/21/JavaScript深入之从原型到原型链/</id>
    <published>2017-05-21T08:51:22.000Z</published>
    <updated>2017-06-03T16:12:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript深入之从原型到原型链"><a href="#JavaScript深入之从原型到原型链" class="headerlink" title="JavaScript深入之从原型到原型链"></a>JavaScript深入之从原型到原型链</h1><p>原文出处： <a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="external">冴羽</a></p>
<blockquote>
<p>JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。</p>
</blockquote>
<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line">person.name = <span class="string">'Kevin'</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></div></pre></td></tr></table></figure>
<p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p>
<p>很简单吧，接下来进入正题：</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 虽然写在注释里，但是你要注意：</span></div><div class="line"><span class="comment">// prototype是函数才会有的属性</span></div><div class="line">Person.prototype.name = <span class="string">'Kevin'</span>;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// Kevin</span></div><div class="line"><span class="built_in">console</span>.log(person2.name) <span class="comment">// Kevin</span></div></pre></td></tr></table></figure>
<p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p>
<p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p>
<p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png" alt="构造函数和实例原型的关系图" title="">
                </div>
                <div class="image-caption">构造函数和实例原型的关系图</div>
            </figure>
<p>在这张图中我们用 Object.prototype 表示实例原型。</p>
<p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p>
<p>为了证明这一点,我们可以在火狐或者谷歌中输入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>于是我们更新下关系图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png" alt="实例与实例原型的关系图" title="">
                </div>
                <div class="image-caption">实例与实例原型的关系图</div>
            </figure>
<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor﻿，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<p>为了验证这一点，我们可以尝试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>所以再更新下关系图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png" alt="实例原型与构造函数的关系图" title="">
                </div>
                <div class="image-caption">实例原型与构造函数的关系图</div>
            </figure>
<p>综上我们已经得出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></div><div class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p>
<h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">'Kevin'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person.name = <span class="string">'Daisy'</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Daisy</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></div></pre></td></tr></table></figure>
<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了  name 属性，结果为 Kevin。</p>
<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>
<h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">obj.name = <span class="string">'Kevin'</span></div><div class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// Kevin</span></div></pre></td></tr></table></figure>
<p>所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png" alt="原型的原型关系图" title="">
                </div>
                <div class="image-caption">原型的原型关系图</div>
            </figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那 Object.prototype 的原型呢？</p>
<p>null，不信我们可以打印：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>所以查到属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>所以最后一张关系图就是</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="原型链示意图" title="">
                </div>
                <div class="image-caption">原型链示意图</div>
            </figure>
<p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最后，补充三点大家可能不会注意的地方：</p>
<h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><p>首先是 constructor 属性，我们看个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person.constructor === Person.prototype.constructor</div></pre></td></tr></table></figure>
<h3 id="proto-1"><a href="#proto-1" class="headerlink" title="__proto__"></a>__proto__</h3><p>其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p>
<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>
<h2 id="下一篇文章"><a href="#下一篇文章" class="headerlink" title="下一篇文章"></a>下一篇文章</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="external">JavaScript深入之词法作用域和动态作用域</a></p>
<h2 id="深入系列"><a href="#深入系列" class="headerlink" title="深入系列"></a>深入系列</h2><p>JavaScript深入系列目录地址：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="external">https://github.com/mqyqingfeng/Blog</a>。</p>
<p>JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。</p>
<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript深入之从原型到原型链&quot;&gt;&lt;a href=&quot;#JavaScript深入之从原型到原型链&quot; class=&quot;headerlink&quot; title=&quot;JavaScript深入之从原型到原型链&quot;&gt;&lt;/a&gt;JavaScript深入之从原型到原型链&lt;/h1&gt;&lt;
    
    </summary>
    
    
      <category term="原型" scheme="http://huayan.site/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="http://huayan.site/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="prototype" scheme="http://huayan.site/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 面试中常见算法问题详解</title>
    <link href="http://huayan.site/2017/05/15/JavaScript-%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://huayan.site/2017/05/15/JavaScript-面试中常见算法问题详解/</id>
    <published>2017-05-15T08:51:22.000Z</published>
    <updated>2017-05-17T13:28:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000008397935" target="_blank" rel="external">原文出处：王下邀月熊_Chevalier</a></p>
<h3 id="JavaScript-Specification"><a href="#JavaScript-Specification" class="headerlink" title="JavaScript Specification"></a>JavaScript Specification</h3><h4 id="阐述下-JavaScript-中的变量提升"><a href="#阐述下-JavaScript-中的变量提升" class="headerlink" title="阐述下 JavaScript 中的变量提升"></a>阐述下 JavaScript 中的变量提升</h4><p>所谓提升，顾名思义即是 JavaScript 会将所有的声明提升到当前作用域的顶部。这也就意味着我们可以在某个变量声明前就使用该变量，不过虽然 JavaScript 会将声明提升到顶部，但是并不会执行真的初始化过程。</p>
<h4 id="阐述下-use-strict-的作用"><a href="#阐述下-use-strict-的作用" class="headerlink" title="阐述下 use strict; 的作用"></a>阐述下 use strict; 的作用</h4><p>use strict; 顾名思义也就是 JavaScript 会在所谓严格模式下执行，其一个主要的优势在于能够强制开发者避免使用未声明的变量。对于老版本的浏览器或者执行引擎则会自动忽略该指令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Example of strict mode</span></div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line">catchThemAll();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">catchThemAll</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  x = <span class="number">3.14</span>; <span class="comment">// Error will be thrown</span></div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解释下什么是-Event-Bubbling-以及如何避免"><a href="#解释下什么是-Event-Bubbling-以及如何避免" class="headerlink" title="解释下什么是 Event Bubbling 以及如何避免"></a>解释下什么是 Event Bubbling 以及如何避免</h4><p>Event Bubbling 即指某个事件不仅会触发当前元素，还会以嵌套顺序传递到父元素中。直观而言就是对于某个子元素的点击事件同样会被父元素的点击事件处理器捕获。避免 Event Bubbling 的方式可以使用event.stopPropagation() 或者 IE 9 以下使用event.cancelBubble。</p>
<p>== 与 === 的区别是什么<br>=== 也就是所谓的严格比较，关键的区别在于=== 会同时比较类型与值，而不是仅比较值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Example of comparators</div><div class="line">0 == false; // true</div><div class="line">0 === false; // false</div><div class="line"></div><div class="line">2 == &apos;2&apos;; // true</div><div class="line">2 === &apos;2&apos;; // false</div></pre></td></tr></table></figure></p>
<h4 id="解释下-null-与-undefined-的区别"><a href="#解释下-null-与-undefined-的区别" class="headerlink" title="解释下 null 与 undefined 的区别"></a>解释下 null 与 undefined 的区别</h4><p>JavaScript 中，null 是一个可以被分配的值，设置为 null 的变量意味着其无值。而 undefined 则代表着某个变量虽然声明了但是尚未进行过任何赋值。</p>
<h4 id="解释下-Prototypal-Inheritance-与-Classical-Inheritance-的区别"><a href="#解释下-Prototypal-Inheritance-与-Classical-Inheritance-的区别" class="headerlink" title="解释下 Prototypal Inheritance 与 Classical Inheritance 的区别"></a>解释下 Prototypal Inheritance 与 Classical Inheritance 的区别</h4><p>在类继承中，类是不可变的，不同的语言中对于多继承的支持也不一样，有些语言中还支持接口、final、abstract 的概念。而原型继承则更为灵活，原型本身是可以可变的，并且对象可能继承自多个原型。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>找出整型数组中乘积最大的三个数<br>给定一个包含整数的无序数组，要求找出乘积最大的三个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> unsorted_array = [<span class="number">-10</span>, <span class="number">7</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">-10</span>, <span class="number">-70</span>];</div><div class="line"></div><div class="line">computeProduct(unsorted_array); <span class="comment">// 21000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortIntegers</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a - b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// greatest product is either (min1 * min2 * max1 || max1 * max2 * max3)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeProduct</span>(<span class="params">unsorted</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> sorted_array = unsorted.sort(sortIntegers),</div><div class="line">    product1 = <span class="number">1</span>,</div><div class="line">    product2 = <span class="number">1</span>,</div><div class="line">    array_n_element = sorted_array.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Get the product of three largest integers in sorted array</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = array_n_element; x &gt; array_n_element - <span class="number">3</span>; x--) &#123;</div><div class="line">      product1 = product1 * sorted_array[x];</div><div class="line">  &#125;</div><div class="line">  product2 = sorted_array[<span class="number">0</span>] * sorted_array[<span class="number">1</span>] * sorted_array[array_n_element];</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (product1 &gt; product2) <span class="keyword">return</span> product1;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> product2</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="寻找连续数组中的缺失数"><a href="#寻找连续数组中的缺失数" class="headerlink" title="寻找连续数组中的缺失数"></a>寻找连续数组中的缺失数</h4><blockquote>
<p>给定某无序数组，其包含了 n 个连续数字中的 n - 1 个，已知上下边界，要求以O(n)的复杂度找出缺失的数字。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The output of the function should be 8</span></div><div class="line"><span class="keyword">var</span> array_of_integers = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>];</div><div class="line"><span class="keyword">var</span> upper_bound = <span class="number">9</span>;</div><div class="line"><span class="keyword">var</span> lower_bound = <span class="number">1</span>;</div><div class="line"></div><div class="line">findMissingNumber(array_of_integers, upper_bound, lower_bound); <span class="comment">//8</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMissingNumber</span>(<span class="params">array_of_integers, upper_bound, lower_bound</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Iterate through array to find the sum of the numbers</span></div><div class="line">  <span class="keyword">var</span> sum_of_integers = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array_of_integers.length; i++) &#123;</div><div class="line">    sum_of_integers += array_of_integers[i];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 以高斯求和公式计算理论上的数组和</span></div><div class="line">  <span class="comment">// Formula: [(N * (N + 1)) / 2] - [(M * (M - 1)) / 2];</span></div><div class="line">  <span class="comment">// N is the upper bound and M is the lower bound</span></div><div class="line"></div><div class="line">  upper_limit_sum = (upper_bound * (upper_bound + <span class="number">1</span>)) / <span class="number">2</span>;</div><div class="line">  lower_limit_sum = (lower_bound * (lower_bound - <span class="number">1</span>)) / <span class="number">2</span>;</div><div class="line"></div><div class="line">  theoretical_sum = upper_limit_sum - lower_limit_sum;</div><div class="line"></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="keyword">return</span> (theoretical_sum - sum_of_integers)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><blockquote>
<p>给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6 Implementation</span></div><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>];</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array)); <span class="comment">// [1, 2, 3, 5, 9, 8]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ES5 Implementation</span></div><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>];</div><div class="line"></div><div class="line">uniqueArray(array); <span class="comment">// [1, 2, 3, 5, 9, 8]</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArray</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> hashmap = &#123;&#125;;</div><div class="line">  <span class="keyword">var</span> unique = [];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">    <span class="comment">// If key returns null (unique), it is evaluated as false.</span></div><div class="line">    <span class="keyword">if</span>(!hashmap.hasOwnProperty([array[i]])) &#123;</div><div class="line">      hashmap[array[i]] = <span class="number">1</span>;</div><div class="line">      unique.push(array[i]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> unique;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="数组中元素最大差值计算"><a href="#数组中元素最大差值计算" class="headerlink" title="数组中元素最大差值计算"></a>数组中元素最大差值计算</h4><blockquote>
<p>给定某无序数组，求取任意两个元素之间的最大差值，注意，这里要求差值计算中较小的元素下标必须小于较大元素的下标。譬如[7, 8, 4, 9, 9, 15, 3, 1, 10]这个数组的计算值是 11( 15 - 4 ) 而不是 14(15 - 1)，因为 15 的下标小于 1。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">10</span>];</div><div class="line"><span class="comment">// [7, 8, 4, 9, 9, 15, 3, 1, 10] would return `11` based on the difference between `4` and `15`</span></div><div class="line"><span class="comment">// Notice: It is not `14` from the difference between `15` and `1` because 15 comes before 1.</span></div><div class="line"></div><div class="line">findLargestDifference(array);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLargestDifference</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 如果数组仅有一个元素，则直接返回 -1</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="comment">// current_min 指向当前的最小值</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> current_min = array[<span class="number">0</span>];</div><div class="line">  <span class="keyword">var</span> current_max_difference = <span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="comment">// 遍历整个数组以求取当前最大差值，如果发现某个最大差值，则将新的值覆盖 current_max_difference</span></div><div class="line">  <span class="comment">// 同时也会追踪当前数组中的最小值，从而保证 `largest value in future` - `smallest value before it`</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (array[i] &gt; current_min &amp;&amp; (array[i] - current_min &gt; current_max_difference)) &#123;</div><div class="line">      current_max_difference = array[i] - current_min;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] &lt;= current_min) &#123;</div><div class="line">      current_min = array[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If negative or 0, there is no largest difference</span></div><div class="line">  <span class="keyword">if</span> (current_max_difference &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> current_max_difference;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数组中元素乘积"><a href="#数组中元素乘积" class="headerlink" title="数组中元素乘积"></a>数组中元素乘积</h4><blockquote>
<p>给定某无序数组，要求返回新数组 output ，其中 output[i] 为原数组中除了下标为 i 的元素之外的元素乘积，要求以 O(n) 复杂度实现：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> firstArray = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> secondArray = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> thirdArray = [<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">2</span>];</div><div class="line"></div><div class="line">productExceptSelf(firstArray); <span class="comment">// [8, 8, 4, 16]</span></div><div class="line">productExceptSelf(secondArray); <span class="comment">// [0, 0, 0, 0]</span></div><div class="line">productExceptSelf(thirdArray); <span class="comment">// [12, 12, 8, -12]</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">productExceptSelf</span>(<span class="params">numArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">var</span> size = numArray.length;</div><div class="line">  <span class="keyword">var</span> output = [];</div><div class="line"></div><div class="line">  <span class="comment">// From first array: [1, 2, 4, 16]</span></div><div class="line">  <span class="comment">// The last number in this case is already in the right spot (allows for us)</span></div><div class="line">  <span class="comment">// to just multiply by 1 in the next step.</span></div><div class="line">  <span class="comment">// This step essentially gets the product to the left of the index at index + 1</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; size; x++) &#123;</div><div class="line">      output.push(product);</div><div class="line">      product = product * numArray[x];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// From the back, we multiply the current output element (which represents the product</span></div><div class="line">  <span class="comment">// on the left of the index, and multiplies it by the product on the right of the element)</span></div><div class="line">  <span class="keyword">var</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = size - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i--) &#123;</div><div class="line">      output[i] = output[i] * product;</div><div class="line">      product = product * numArray[i];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> output;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h4><blockquote>
<p>给定两个数组，要求求出两个数组的交集，注意，交集中的元素应该是唯一的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> firstArray = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> secondArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>];</div><div class="line"></div><div class="line">intersection(firstArray, secondArray); <span class="comment">// [2, 1]</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">firstArray, secondArray</span>) </span>&#123;</div><div class="line">  <span class="comment">// The logic here is to create a hashmap with the elements of the firstArray as the keys.</span></div><div class="line">  <span class="comment">// After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash</span></div><div class="line">  <span class="comment">// If it does exist, add that element to the new array.</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> hashmap = &#123;&#125;;</div><div class="line">  <span class="keyword">var</span> intersectionArray = [];</div><div class="line"></div><div class="line">  firstArray.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">    hashmap[element] = <span class="number">1</span>;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added</span></div><div class="line">  secondArray.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hashmap[element] === <span class="number">1</span>) &#123;</div><div class="line">      intersectionArray.push(element);</div><div class="line">      hashmap[element]++;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> intersectionArray;</div><div class="line"></div><div class="line">  <span class="comment">// Time complexity O(n), Space complexity O(n)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><blockquote>
<p>颠倒字符串<br>给定某个字符串，要求将其中单词倒转之后然后输出，譬如”Welcome to this Javascript Guide!” 应该输出为 “emocleW ot siht tpircsavaJ !ediuG”。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"Welcome to this Javascript Guide!"</span>;</div><div class="line"></div><div class="line"><span class="comment">// Output becomes !ediuG tpircsavaJ siht ot emocleW</span></div><div class="line"><span class="keyword">var</span> reverseEntireSentence = reverseBySeparator(string, <span class="string">""</span>);</div><div class="line"></div><div class="line"><span class="comment">// Output becomes emocleW ot siht tpircsavaJ !ediuG</span></div><div class="line"><span class="keyword">var</span> reverseEachWord = reverseBySeparator(reverseEntireSentence, <span class="string">" "</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseBySeparator</span>(<span class="params">string, separator</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> string.split(separator).reverse().join(separator);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="乱序同字母字符串"><a href="#乱序同字母字符串" class="headerlink" title="乱序同字母字符串"></a>乱序同字母字符串</h4><blockquote>
<p>给定两个字符串，判断是否颠倒字母而成的字符串，譬如Mary与Army就是同字母而顺序颠倒：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> firstWord = <span class="string">"Mary"</span>;</div><div class="line"><span class="keyword">var</span> secondWord = <span class="string">"Army"</span>;</div><div class="line"></div><div class="line">isAnagram(firstWord, secondWord); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAnagram</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line">  <span class="comment">// For case insensitivity, change both words to lowercase.</span></div><div class="line">  <span class="keyword">var</span> a = first.toLowerCase();</div><div class="line">  <span class="keyword">var</span> b = second.toLowerCase();</div><div class="line"></div><div class="line">  <span class="comment">// Sort the strings, and join the resulting array to a string. Compare the results</span></div><div class="line">  a = a.split(<span class="string">""</span>).sort().join(<span class="string">""</span>);</div><div class="line">  b = b.split(<span class="string">""</span>).sort().join(<span class="string">""</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> a === b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="会问字符串"><a href="#会问字符串" class="headerlink" title="会问字符串"></a>会问字符串</h4><blockquote>
<p>判断某个字符串是否为回文字符串，譬如racecar与race car都是回文字符串：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">isPalindrome(<span class="string">"racecar"</span>); <span class="comment">// true</span></div><div class="line">isPalindrome(<span class="string">"race Car"</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">  <span class="comment">// Replace all non-letter chars with "" and change to lowercase</span></div><div class="line">  <span class="keyword">var</span> lettersOnly = word.toLowerCase().replace(<span class="regexp">/\s/g</span>, <span class="string">""</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Compare the string with the reversed version of the string</span></div><div class="line">  <span class="keyword">return</span> lettersOnly === lettersOnly.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h4><blockquote>
<p>使用两个栈实现入队与出队</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inputStack = []; <span class="comment">// First stack</span></div><div class="line"><span class="keyword">var</span> outputStack = []; <span class="comment">// Second stack</span></div><div class="line"></div><div class="line"><span class="comment">// For enqueue, just push the item into the first stack</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span>(<span class="params">stackInput, item</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> stackInput.push(item);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span>(<span class="params">stackInput, stackOutput</span>) </span>&#123;</div><div class="line">  <span class="comment">// Reverse the stack such that the first element of the output stack is the</span></div><div class="line">  <span class="comment">// last element of the input stack. After that, pop the top of the output to</span></div><div class="line">  <span class="comment">// get the first element that was ever pushed into the input stack</span></div><div class="line">  <span class="keyword">if</span> (stackOutput.length &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">while</span>(stackInput.length &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">var</span> elementToOutput = stackInput.pop();</div><div class="line">      stackOutput.push(elementToOutput);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> stackOutput.pop();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="判断大括号是否闭合"><a href="#判断大括号是否闭合" class="headerlink" title="判断大括号是否闭合"></a>判断大括号是否闭合</h4><blockquote>
<p>创建一个函数来判断给定的表达式中的大括号是否闭合：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> expression = <span class="string">"&#123;&#123;&#125;&#125;&#123;&#125;&#123;&#125;"</span></div><div class="line"><span class="keyword">var</span> expressionFalse = <span class="string">"&#123;&#125;&#123;&#123;&#125;"</span>;</div><div class="line"></div><div class="line">isBalanced(expression); <span class="comment">// true</span></div><div class="line">isBalanced(expressionFalse); <span class="comment">// false</span></div><div class="line">isBalanced(<span class="string">""</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBalanced</span>(<span class="params">expression</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> checkString = expression;</div><div class="line">  <span class="keyword">var</span> stack = [];</div><div class="line"></div><div class="line">  <span class="comment">// If empty, parentheses are technically balanced</span></div><div class="line">  <span class="keyword">if</span> (checkString.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; checkString.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(checkString[i] === <span class="string">'&#123;'</span>) &#123;</div><div class="line">      stack.push(checkString[i]);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkString[i] === <span class="string">'&#125;'</span>) &#123;</div><div class="line">      <span class="comment">// Pop on an empty array is undefined</span></div><div class="line">      <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        stack.pop();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If the array is not empty, it is not balanced</span></div><div class="line">  <span class="keyword">if</span> (stack.pop()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>递归</p>
<h4 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h4><blockquote>
<p>通过某个递归函数将输入的数字转化为二进制字符串：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">decimalToBinary(<span class="number">3</span>); <span class="comment">// 11</span></div><div class="line">decimalToBinary(<span class="number">8</span>); <span class="comment">// 1000</span></div><div class="line">decimalToBinary(<span class="number">1000</span>); <span class="comment">// 1111101000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToBinary</span>(<span class="params">digit</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(digit &gt;= <span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">// If digit is not divisible by 2 then recursively return proceeding</span></div><div class="line">    <span class="comment">// binary of the digit minus 1, 1 is added for the leftover 1 digit</span></div><div class="line">    <span class="keyword">if</span> (digit % <span class="number">2</span>) &#123;</div><div class="line">      <span class="keyword">return</span> decimalToBinary((digit - <span class="number">1</span>) / <span class="number">2</span>) + <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Recursively return proceeding binary digits</span></div><div class="line">      <span class="keyword">return</span> decimalToBinary(digit / <span class="number">2</span>) + <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Exit condition</span></div><div class="line">    <span class="keyword">return</span> <span class="string">''</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveBinarySearch</span>(<span class="params">array, value, leftPosition, rightPosition</span>) </span>&#123;</div><div class="line">  <span class="comment">// Value DNE</span></div><div class="line">  <span class="keyword">if</span> (leftPosition &gt; rightPosition) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> middlePivot = <span class="built_in">Math</span>.floor((leftPosition + rightPosition) / <span class="number">2</span>);</div><div class="line">  <span class="keyword">if</span> (array[middlePivot] === value) &#123;</div><div class="line">    <span class="keyword">return</span> middlePivot;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[middlePivot] &gt; value) &#123;</div><div class="line">    <span class="keyword">return</span> recursiveBinarySearch(array, value, leftPosition, middlePivot - <span class="number">1</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> recursiveBinarySearch(array, value, middlePivot + <span class="number">1</span>, rightPosition);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><blockquote>
<p>判断是否为 2 的指数值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">isPowerOfTwo(<span class="number">4</span>); <span class="comment">// true</span></div><div class="line">isPowerOfTwo(<span class="number">64</span>); <span class="comment">// true</span></div><div class="line">isPowerOfTwo(<span class="number">1</span>); <span class="comment">// true</span></div><div class="line">isPowerOfTwo(<span class="number">0</span>); <span class="comment">// false</span></div><div class="line">isPowerOfTwo(<span class="number">-1</span>); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// For the non-zero case:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPowerOfTwo</span>(<span class="params">number</span>) </span>&#123;</div><div class="line">  <span class="comment">// `&amp;` uses the bitwise n.</span></div><div class="line">  <span class="comment">// In the case of number = 4; the expression would be identical to:</span></div><div class="line">  <span class="comment">// `return (4 &amp; 3 === 0)`</span></div><div class="line">  <span class="comment">// In bitwise, 4 is 100, and 3 is 011. Using &amp;, if two values at the same</span></div><div class="line">  <span class="comment">// spot is 1, then result is 1, else 0. In this case, it would return 000,</span></div><div class="line">  <span class="comment">// and thus, 4 satisfies are expression.</span></div><div class="line">  <span class="comment">// In turn, if the expression is `return (5 &amp; 4 === 0)`, it would be false</span></div><div class="line">  <span class="comment">// since it returns 101 &amp; 100 = 100 (NOT === 0)</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> number &amp; (number - <span class="number">1</span>) === <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// For zero-case:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPowerOfTwoZeroCase</span>(<span class="params">number</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (number !== <span class="number">0</span>) &amp;&amp; ((number &amp; (number - <span class="number">1</span>)) === <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008397935&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文出处：王下邀月熊_Chevalier&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;JavaScript-Spec
    
    </summary>
    
    
      <category term="javascript" scheme="http://huayan.site/tags/javascript/"/>
    
      <category term="算法" scheme="http://huayan.site/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈模块化加载的实现原理</title>
    <link href="http://huayan.site/2017/05/10/%E6%B5%85%E8%B0%88%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://huayan.site/2017/05/10/浅谈模块化加载的实现原理/</id>
    <published>2017-05-10T08:51:22.000Z</published>
    <updated>2017-05-17T13:48:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载来自: <a href="http://caibaojian.com/module-definition.html" target="_blank" rel="external">前端开发博客</a></p>
<h2 id="浅谈模块化加载的实现原理"><a href="#浅谈模块化加载的实现原理" class="headerlink" title="浅谈模块化加载的实现原理"></a>浅谈模块化加载的实现原理</h2><p>相信很多人都用过 seajs、 requirejs 等这些模块加载器，他们都是十分便捷的工程管理工具，简化了代码的结构，更重要的是消除了各种文件依赖和命名冲突问题，并利用 AMD / CMD 规范统一了格式。如果你不太明白模块化的作用，建议看看玉伯写的<a href="https://github.com/seajs/seajs/issues/547" target="_blank" rel="external">一篇文章</a>。</p>
<ul>
<li><p>一是按需加载，业务越来越大，基础代码也会越来越多，开发人员可能开发了一百个小工具，而且都塞在一个叫做 utils.js 的包里，但是一个页面可能只需要三到五个小工具，如果直接去加载这个 utils.js 岂不是很大的浪费，PC 端还好，主要是无线端，省下 1KB 那都是很大的价值啊，所以呢，如今很多框架的开发都体现出细颗粒度的分化，像百度研究比较卖力的 <a href="https://github.com/BaiduFE/Tangram-base" target="_blank" rel="external">tangram</a>，阿里放满产品线的 <a href="http://docs.kissyui.com/" target="_blank" rel="external">kissy</a>，几乎是细分到了微粒程度，这种细分方式也促进了模块化加载技术的发展，比如为了减少请求数量，kissy 的 config 中开启 combo 就可以合并多个请求为一个等等。</p>
</li>
<li><p>第二点，应该也是从服务器那边参考而来的，服务器脚本很多都是以文件为单位分离的，如果要利用其它文件的功能，可以轻而易举的 require 或者 include 进来，我没有去研究这些加载函数的内部实现原理，稍微猜猜应该是把文件写入到缓存，遇到 include 之类的加载函数，暂停写入，找到需要 include 的文件地址，把找到的文件接着上面继续写入缓存，以此类推，直到结束，然后编译器进行统一编译。</p>
</li>
</ul>
<h3 id="一、模块化加载的技术原理"><a href="#一、模块化加载的技术原理" class="headerlink" title="一、模块化加载的技术原理"></a>一、模块化加载的技术原理</h3><p>先不考虑各种模块定义规范，本文目的只是简要的分析加载原理， CMD / AMD 规范虽内容然不多，但是要实现起来，工程量还是不小。文章后面会提到。</p>
<h4 id="1-数据模块的加载"><a href="#1-数据模块的加载" class="headerlink" title="1. 数据模块的加载"></a>1. 数据模块的加载</h4><p>既然是模块化加载，想办法把模块内容拿到当然是重头戏，无论是 script 还是 css 文件的加载，一个 script 或者 link 标签就可以搞定问题，不过我这里采用的是 ajax，目的是为了拿到 script 的代码，也是为了照顾后面要说的 CMD 规范。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">require</span> = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(), res;</div><div class="line">    xhr.open(<span class="string">"GET"</span>, path, <span class="literal">true</span>);</div><div class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</div><div class="line">            <span class="comment">// 获取源码</span></div><div class="line">            res = xhr.responseText;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    xhr.send();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>创建 script 标签加载脚本不会存在跨域问题，不过拿到的脚本会被浏览器立马解析出来，如果要做同异步的处理就比较麻烦了。没有跨域的文件我们就通过上面的方式加载，如果脚本跨域了，再去创建标签，让文档自己去加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跨域处理</span></div><div class="line"><span class="keyword">if</span>(crossDomain)&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    script.src = path;</div><div class="line"></div><div class="line">    (<span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>] || <span class="built_in">document</span>.body).appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-解析模块的层次依赖关系"><a href="#2-解析模块的层次依赖关系" class="headerlink" title="2. 解析模块的层次依赖关系"></a>2. 解析模块的层次依赖关系</h4><p>模块之间存在依赖关系是十分正常的，如一个工程的文件结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">project/</div><div class="line">├── css/</div><div class="line">│   └── main.css</div><div class="line">├── js/</div><div class="line">│   ├── require.js</div><div class="line">│   └── modlues/</div><div class="line">│     ├── a.js</div><div class="line">│     ├── b.js</div><div class="line">│     └── c.js</div><div class="line">└── index.html</div></pre></td></tr></table></figure></p>
<p>而这里几个模块的依赖关系是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">            ┌&gt; a.js -&gt; b.js</div><div class="line">index.html -|</div><div class="line">            └&gt; c.js</div><div class="line"></div><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"./js/test/b.js"</span>);</div><div class="line"></div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"i am b"</span>);</div><div class="line"></div><div class="line"><span class="comment">// c.js</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"i am c"</span>);</div></pre></td></tr></table></figure>
<p>我们要从 index.html 中利用 require.js 获取这一连串的依赖关系，一般采用的方式就是正则匹配。如下：先拿到 function 的代码，然后正则匹配出第一层的依赖关系，接着加载匹配到关系的代码，继续匹配。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// index.html</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./js/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./js/modlues/a.js"</span>);</div><div class="line">        <span class="keyword">var</span> c = <span class="built_in">require</span>(<span class="string">"./js/modlues/c.js"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// toString 方法可以拿到 test 函数的 code</span></div><div class="line">    start(test.toString());</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>整个函数的入口是 start，正则表达式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r = <span class="regexp">/require\((.*)\)/g</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> start = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">while</span>(match = r.exec(str)) &#123;</div><div class="line">        <span class="built_in">console</span>.log(match[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>由此我们拿到了第一层的依赖关系，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"./js/modlues/a.js"</span>, <span class="string">"./js/modlues/c.js"</span>]</div></pre></td></tr></table></figure></p>
<p>接着要拿到 a.js 和 b.js 的文件层次依赖，之前我们写了一个 require 函数，这个函数可以拿到脚本的代码内容，不过这个 require 函数要稍微修改下，递归去查询和下载代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> start = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">while</span>(match = r.exec(str)) &#123;</div><div class="line">        <span class="built_in">console</span>.log(match &amp;&amp; match[<span class="number">1</span>]);</div><div class="line">        <span class="comment">// 如果匹配到了内容，下载 path 对应的源码</span></div><div class="line">        match &amp;&amp; match[<span class="number">1</span>] &amp;&amp; <span class="built_in">require</span>(match[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> <span class="built_in">require</span> = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(), res;</div><div class="line">    xhr.open(<span class="string">"GET"</span>, path, <span class="literal">true</span>);</div><div class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</div><div class="line">            res = xhr.responseText;</div><div class="line">            <span class="comment">// 缓存文件</span></div><div class="line">            cache[path] = res;</div><div class="line">            <span class="comment">// 继续递归匹配</span></div><div class="line">            start(res);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    xhr.send();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码已经可以很好地拿到文件递归关系了:<br><img src="1.jpg"></p>
<h4 id="3-添加事件机制，优化管理代码"><a href="#3-添加事件机制，优化管理代码" class="headerlink" title="3. 添加事件机制，优化管理代码"></a>3. 添加事件机制，优化管理代码</h4><p>但是我们有必要先把 responseText 缓存起来，如果不缓存文件，直接 eval 得到的 responseText 代码，想想会发生什么问题~ 如果模块之间存在循环引用，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">            ┌&gt; a.js -&gt; b.js</div><div class="line">index.html -|</div><div class="line">            └&gt; b.js -&gt; a.js</div></pre></td></tr></table></figure>
<p>那 start 和 require 将会陷入死循环，不断的加载代码。所以我们需要先拿到依赖关系，然后解构关系，分析出我们需要加载哪些模块。值得注意的是，我们必须按照加载的顺序去 eval 代码，如果 a 依赖 b，先去执行 a 的话，一定会报错！</p>
<p>有两个问题我纠结了半天，上面的请求方式，何时会结束？用什么方式去记录文件依赖关系？</p>
<p>最后还是决定将 start 和 require 两个函数的相互递归修改成一个函数的递归。用一个对象，发起请求时把 URL 作为 key，在这个对象里保存 XHR 对象，XHR 对象请求完成后，把抓取到的新请求再用同样的方式放入这个对象中，同时从这个对象中把自己删除掉，然后判断这个对象上是否存在 key， 如果存在说明还有 XHR 对象没完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r = <span class="regexp">/require\(\s*"(.*)"\s*\)/g</span>;</div><div class="line"><span class="keyword">var</span> cache = &#123;&#125;;    <span class="comment">// 文件缓存</span></div><div class="line"><span class="keyword">var</span> relation = []; <span class="comment">// 依赖过程控制</span></div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;      <span class="comment">// xhr 管理对象</span></div><div class="line"></div><div class="line"><span class="comment">//辅助函数，获取键值数组</span></div><div class="line"><span class="built_in">Object</span>.keys = <span class="built_in">Object</span>.keys || <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">　　  <span class="keyword">var</span> a = [];</div><div class="line">　　  <span class="keyword">for</span>(a[a.length] <span class="keyword">in</span> obj);</div><div class="line">　　  <span class="keyword">return</span> a ;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 入口函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">while</span>(match = r.exec(str))&#123;</div><div class="line">        obj[match[<span class="number">1</span>]] = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">        <span class="built_in">require</span>(obj[match[<span class="number">1</span>]], match[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 递归请求</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">require</span> = <span class="function"><span class="keyword">function</span>(<span class="params">xhr, path</span>)</span>&#123;</div><div class="line">    <span class="comment">//记录依赖过程</span></div><div class="line">    relation.push(path);</div><div class="line"></div><div class="line">    xhr.open(<span class="string">"GET"</span>, path, <span class="literal">true</span>);</div><div class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</div><div class="line">            <span class="keyword">var</span> res = xhr.responseText;</div><div class="line">            <span class="comment">// 缓存文件</span></div><div class="line">            cache[path] = res;</div><div class="line">            <span class="comment">// 从xhr对象管理器中删除已经加载完毕的函数</span></div><div class="line">            <span class="keyword">delete</span> obj[path];</div><div class="line"></div><div class="line">            <span class="comment">// 如果obj为空则触发 allLoad 事件</span></div><div class="line">            <span class="built_in">Object</span>.keys(obj).length == <span class="number">0</span> ? Event.trigger(<span class="string">"allLoad"</span>) : <span class="keyword">void</span> <span class="number">0</span>;</div><div class="line">            <span class="comment">//递归条件</span></div><div class="line">            <span class="keyword">while</span>(match = r.exec(res))&#123;</div><div class="line">                obj[match[<span class="number">1</span>]] = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">                <span class="built_in">require</span>(obj[match[<span class="number">1</span>]], match[<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    xhr.send();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码已经基本完成了文件依赖分析，文件的加载和缓存工作了</p>
<ol>
<li>CMD 规范的介绍</li>
</ol>
<p>上面写了一大堆内容，也实现了模块加载器的原型，但是放在实际应用中，他就是个废品，回到最开始，我们为什么要使用模块化加载。目的是为了不去使用麻烦的命名空间，把复杂的模块依赖交给 require 这个函数去管理，但实际上呢，上面拿到的所有模块都是暴露在全局变量中的，也就是说，如果 a.js 和 b.js 中存在命名相同的变量，后者将会覆盖前者，这是我们不愿意看到的。为了处理此类问题，我们有必要把所有的模块都放到一个闭包中，这样一来，只要不使用 window.vars 命名，闭包之间的变量是不会相互影响的。我们可以使用自己的方式去管理代码，不过有人已经研究处理一套标准，而且是全球统一，那就拿着用吧~</p>
<p>关于 CMD 规范，我这里就不多说了，可以去看看草案，玉伯也翻译了一份，戳我。每一模块有且仅有一个对外公开的接口 exports，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 对外提供 foo 属性</span></div><div class="line">  exports.foo = <span class="string">'bar'</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 对外提供 doSomething 方法</span></div><div class="line">  exports.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>剩下的工作就是针对 CMD 规范写一套符合标准的代码接口，这个比较琐碎，就不写了。</p>
<h3 id="二、额外的话题"><a href="#二、额外的话题" class="headerlink" title="二、额外的话题"></a>二、额外的话题</h3><p>上面的代码中提到了关于 Event 的事件管理。在模块全部加在完毕之后，需要有个东西告诉你，所以顺手写了一个 Event 的事件管理器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Event</span></div><div class="line"><span class="keyword">var</span> Event = &#123;&#125;;</div><div class="line">Event.events = [];</div><div class="line">Event.on = <span class="function"><span class="keyword">function</span>(<span class="params">evt, func</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; Event.events.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(Event.events[i].evt == evt)&#123;</div><div class="line">            Event.events[i].func.push(func);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Event.events.push(&#123;</div><div class="line">        <span class="attr">evt</span>: evt,</div><div class="line">        <span class="attr">func</span>: [func]</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line">Event.trigger = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; Event.events.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(Event.events[i].evt == evt)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; Event.events[i].func.length; j++)&#123;</div><div class="line">                Event.events[i].func[j]();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Event.off = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; Event.events.length; i++)&#123;</div><div class="line">        Event.events.splice(i, <span class="number">1</span>);</div><div class="line">    &#125;       </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我觉得 seajs 是一个很不错的模块加载器，如果感兴趣，可以去看看他的源码实现，代码不长，只有一千多行。模块的加载它采用的是创建文本节点，让文档去加载模块，实时查看状态为 interactive 的 script 标签，如果处于交互状态就拿到他的代码，接着删除节点。当节点数目为 0 的时候，加载工作完成。</p>
<p>本文没有考虑 css 文件的加载问题，我们可以把它当做一个没有 require 关键词的 js 文件，或者把它匹配出来之后另作处理，因为他是不可能存在模块依赖关系的。</p>
<h3 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h3><p><a href="https://github.com/seajs/issues" target="_blank" rel="external">seajs</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载来自: &lt;a href=&quot;http://caibaojian.com/module-definition.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端开发博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;浅谈模块化加载的实现原理&quot;&gt;&lt;a href=
    
    </summary>
    
    
      <category term="模块化" scheme="http://huayan.site/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="AMD" scheme="http://huayan.site/tags/AMD/"/>
    
      <category term="CMD" scheme="http://huayan.site/tags/CMD/"/>
    
      <category term="requirejs" scheme="http://huayan.site/tags/requirejs/"/>
    
  </entry>
  
</feed>
